{"meta":{"title":"☁ YunBJ","subtitle":"","description":"My Blog.","author":"☁ YunBJ","url":"https://yunbujian.github.io","root":"/"},"posts":[{"tags":[],"title":"","date":"2022/04/01","text":"怎么加notion的图标 #0A0A0A 黑色 #FFEC02 黄色，标注","permalink":"https://yunbujian.github.io/2022/04/01/%E8%AE%B0%E5%BD%95%E6%8E%92%E7%89%88%E6%A0%BC%E5%BC%8F/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"title":"三月回顾总结","date":"2022/04/01","text":"「三月 · 回顾」3月看的3部电影和4本书📕阅读：《文明、现代化、价值投资与中国》《容忍与自由》《小狗钱钱》《我的第一本算法书》 🎦观影：《请回答，1988》《罗马假日》《教父》 🏃🏻运动：跑步、撸铁、拉伸瑜伽 💯算法：数组、字符串、链表、树… 🙇科研项目、四月规划、记在后面 1、阅读1/《文明、现代化、价值投资与中国》–李录 这本是和共读群战友一起看完的，只看完下半部分。上半部分是李录老师的研究论文，下半部分是老师的演讲汇总。 关于价值投资的东西，这里就不赘述了，但是会影响我对投机和投资，究竟哪里是自己的能力圈有了更好的了解。还有李录老师对研究的严谨态度值得我一辈子学习。 我年轻的时候一直在追寻人生的意义，后来我渐渐悟到其实人生真正的意义就是追求真知。 对知识绝对的坦诚，切己体察，将所学道理亲自体验，躬行实践。而不仅仅满足于“噢，我get到一个知识”。 物质世界基本上是一个熵增的世界，能量从高处往低处流，大的总是能够吃掉小的，体积大的星球撞击体积小的星球必然能将其压碎，整个地球、宇宙到一定程度也会走向湮灭。但人类世界不同，人可以把世界变成一个熵减的世界，可以让熵倒流。人可以通过学习，从完全无知变得博学；人可以通过修身养性，成为一个道德高尚的人，对社会有贡献的人；人还可以创造出这么多以前根本无法想象的新事物。 想想这几年科技的迅猛发展就知道了，几十年前的人穿越过来一定觉得这是一个魔法世界。 2/ 《容忍与自由》–胡适 在“为什么读书”那一章里，胡适先生提出三个读书的缘由。 站在巨人的肩膀上，尽享人类的宝贵遗产； 书读的多，才理解的进。致其知而后读。读书是为了更好的读书，学会学习是为了更好的学习； 解决实际问题。问题当前，全靠有主意。主意从哪儿来？从学问经验中来。 写论文idea从哪里来？从多看paper中来。 乍一看，不都是些陈词滥调；再一看，发现最简单的道理就是最有用的箴言。 3/ 《小狗钱钱》 这才是理财该有的入门书，富爸爸都不算，不要和我说你没钱理财，因果颠倒了。是先理财才有钱，而不是先有钱再理财。书中的实践部分一句话描述就是除去生活费，把剩余钱的50%投资，想象它是一只会下金蛋的鹅，本金是鹅，收益是金蛋。记住，永远都不要杀死你的鹅。在实践中… 4/ 《我的第一本算法书》 浅显易懂，初中生也能看懂，图文并茂，无算法推导，不容易劝退。但是如果作为职业算法工程师，还有很长的一段路要走。（要是大学时看过这个，怎么也不会只考60分罢… 2、观影1/ 《1988》 重看第二遍，太好看了吧sos，最近的下饭剧，食堂也变得更加美味了，就是容易哽咽到吃不下饭… 2/ 《罗马假日》 赫本好美。让我想到了一句话: 不悔梦归处，只恨太匆匆。 3/ 《教父》 教父：对人际关系的把握值得俺们学习。建立信用是人际关系最好的通行证。教父身边之所以有那么多忠心的人，是因为教父自己是个重情重义，非常讲信用的人。 大哥：大哥非常爱护自己的妹妹。桑提诺是个好大哥，但不是一个好老大。拒绝冲动行事。就算对面是人渣，也要心平气和的用正确的方法制裁他，不然会陷入对方的圈套，这很被动。 （今天4.1号耶，每年今天都会看一部哥哥的电影，缅怀一下这个又帅又有才，未来可能再也不会遇到的男人。看什么好呢…） 3、运动打卡16次，勉强及格。健身房跑步的唯一好处：刘海不会吹起来。 4、算法打卡一个月，有意漏打卡一次。还是摸不清算法的门。 还没想清楚职业规划，就已经开始打卡，担心自己落后，打卡一个月完成了，其实并没有一开始想象中的那么难。但是可能要考虑自己之后的投入产出、是否必要等等。至于为啥俺能坚持的下来，有一些刷题心得分享给大家。 首先是因为跟着LeetCode初级算法专题一道一道题完成，它不会一开始就给你上很难的题目。 其次是根据《微习惯》，我每天只搞懂一道题，这对我来说不会造成太大的心理压力。 最后是我加入了算法打卡微信群，每天都会列出有多少打卡了，多少人没打卡，如果不打卡的话，我觉得很丢人…这也是完成我目的的一种手段。 5、项目课题马上就要结题了，项目预期不能很好的完成，这和我过去的不够付出直接相关。 我意识到自己不是一个好的leader，不会合理用人，鼓励团队的能力简直没有，过于仁慈。天生就更擅长leader的人固然存在，但不代表俺不可以习得。不要放弃修炼自己。 6、四月规划阅读📖《原则》，其实读什么很容易随着当时的想法和需求而改变，但是只要为了变成更好的自己这个大方向不变就没有问题，接下来一个月可能会专注于专业领域的主题阅读。然后就是每天向00提三个问题。整理三月的读书笔记。 7、记在后面这个月挺充实了，过了24岁生日，去了一些地方走走，尝试了很多第一次——第一次看现场脱口秀，第一次玩PS双人成行，第一次去荔湾湖，第一次住摆满一屋子书的酒店。 在书中体会了很多名人的思想、生活和学习，能够深刻的感受到牛人的共通点，对知识的诚实和严谨治学的态度。 回顾自己的一整个三月，也不是全无收获，但总觉得自己怎么又蹉跎了一个月。我不是在凡尔赛，这是我长期的真实感受和状态。 高中时，想着初中怎么那么野、那么疯狂，一点书都不读；大学时，寻思着为什么高中不好好努力，跑到这么远的地方；研究生时，想着大学四年怎么就又过去了…专业课基础一点都不牢固。 或许我们总是对已经过去的时光耿耿于怀，而忽略了接下来的日子才更重要。日复一日，蹉跎岁月。 高中、大学好啊，总会有阶段性的考试，不仅是对一段学习时光的总结，更像是不负韶华的一种证明。这大抵就是为什么考完试会让你放松，满足，欣喜若狂的根本原因吧。 有点怀念高中生活和考研时光了。不悔梦归处，只恨太匆匆。又不愿意再回到那个时候了，那个时候的自己太傻逼，不值得留念。 加油哇，向未来~","permalink":"https://yunbujian.github.io/2022/04/01/2022%E5%B9%B4%E4%B8%89%E6%9C%88%E5%9B%9E%E9%A1%BE/","photos":[]},{"tags":[{"name":"链表","slug":"链表","permalink":"https://yunbujian.github.io/tags/%E9%93%BE%E8%A1%A8/"}],"title":"25、合并两个有序链表（递归没看）","date":"2022/03/24","text":"回顾：[3.24] 题目描述将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 12输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4] 方法1、迭代法回顾思路： 1、设立一个dummy节点，指向-1，pre指向dummy。idx1，idx2指向两个链表；2、判断idx1和idx2的大小，小的赋值给pre.next，接着pre、小的idx都后移，循环遍历。3、直到有一个idx为空，把另外一个idx剩下的赋值给pre。 执行用时：28 ms, 在所有 Python3 提交中击败了98.69%的用户 内存消耗：15 MB, 在所有 Python3 提交中击败了34.82%的用户 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: dummy = ListNode(-1) pre = dummy idx1, idx2 = list1, list2 while idx1 and idx2: if idx1.val &lt;= idx2.val: pre.next = idx1 idx1 = idx1.next else: pre.next = idx2 idx2 = idx2.next pre = pre.next # pre.next = idx1 if idx2 is None else idx2 if idx1 is None: pre.next = idx2 if idx2 is None: pre.next = idx1 return dummy.next","permalink":"https://yunbujian.github.io/2022/03/24/25.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","photos":[]},{"tags":[{"name":"链表","slug":"链表","permalink":"https://yunbujian.github.io/tags/%E9%93%BE%E8%A1%A8/"}],"title":"26、回文链表","date":"2022/03/24","text":"回顾：[3.24] 题目描述给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 12输入：head = [1,2,2,1]输出：true 我的思路：构建一个新链表，存放翻转后的链表；判断两者是否相等，相等返回True 方法1、转数组，双指针执行用时： ms 时间复杂度：O(n) 链表赋值给数组，O(n)。回文判断是否相等执行了O(n/2)，即还是O(n)。总的为O(2n)，所以最终就是O(n)。 空间复杂度：O(n) 使用了一个大小为n的数组存放。 思路总结： 1、复制链表的值给数组 2、双指针，一前一后，向中间遍历，判断是否相等。知道两个指针相遇。 注意： 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: l = list() cur = head while cur: l.append(cur.val) cur = cur.next # return l == l[::-1] lens = len(l) first, end = 0, lens-1 while end-first &gt;= 1: if l[first] != l[end]: return False first +=1 end -= 1 return True 方法2、快慢指针执行用时：772 ms, 在所有 Python3 提交中击败了19.81%的用户 内存消耗：40.3 MB, 在所有 Python3 提交中击败了79.00%的用户 时间复杂度：O(n)，其中 n 指的是链表的大小。 空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。 思路总结：1、找到链表的中间值（利用快慢指针）；2、反转后半链表；3、对比前后链表是否相同，相同返回True。 注意：这里会改变原来的链表 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: # 快慢指针 if head is None: return True fast, slow = head, head while fast.next is not None and fast.next.next is not None: fast = fast.next.next slow = slow.next slow = self.reverseList(slow.next) fast = head while slow: if fast.val != slow.val: return False else: fast = fast.next slow = slow.next return True def reverseList(self, head): pre = None cur = head while cur: next = cur.next cur.next = pre pre = cur cur = next return pre # if head == None or head.next == None: # return head # p = reverseList(head.next) # head.next.next = head # head.next = None # return p","permalink":"https://yunbujian.github.io/2022/03/24/26.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","photos":[]},{"tags":[{"name":"链表","slug":"链表","permalink":"https://yunbujian.github.io/tags/%E9%93%BE%E8%A1%A8/"}],"title":"24、反转链表","date":"2022/03/24","text":"[链表] 24. 反转链表 [3.18]复习重温：[3.24] 题目描述给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 链接：https://leetcode-cn.com/problems/reverse-linked-list 思路： 给了头节点，也就是5.next.data—&gt;4 先把next暂存； 方法1、迭代执行用时：36 ms, 在所有 Python3 提交中击败了**78.80%**的用户 内存消耗：16 MB, 在所有 Python3 提交中击败了**60.12%**的用户 时间复杂度：O*(*n)，其中 n 是链表的长度。需要遍历链表一次。 空间复杂度：O(1)。 思路总结： 注意：注意暂存下一节点；这也算是双指针吧啊哈 1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: prev, curr = None, head while curr != None: next = curr.next curr.next = prev prev = curr curr = next return prev 方法2、递归执行用时：32 ms, 在所有 Python3 提交中击败了92.91%的用户 内存消耗：20.7 MB, 在所有 Python3 提交中击败了10.06%的用户 时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要对链表的每个节点进行反转操作。 空间复杂度：O(n)O(n)，其中 nn 是链表的长度。空间复杂度主要取决于递归调用的栈空间，最多为 nn 层。 思路总结：链表有天然的递归性。 能递归的条件：1、大问题可拆分成两个子问题；2、子问题求解与大问题一样；3、存在最小子问题（也就是终止条件） 代码：1、递：调用函数；2、归：进行反转操作；3、终止条件。 注意： 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if head == None or head.next == None: # 如果链表为空或只有1个节点时，返回head（终止条件） return head p = self.reverseList(head.next) # 递：调用函数 head.next.next = head # 归：反转操作 head.next = None return p","permalink":"https://yunbujian.github.io/2022/03/24/24.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","photos":[]},{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"14、字符串中的第一个唯一字符","date":"2022/03/07","text":"题目描述给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 示例 1：输入: s = “leetcode”输出: 0 示例 2:输入: s = “loveleetcode”输出: 2链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 方法1、哈希表存储字符频次使用哈希表存储字符出现的次数。 思路：先遍历一次，得到所有字符出现的次数。（这个用内置函数collections.Counter()即可。） 再遍历一次，直接返回第一次出现1次的字符的索引。遍历完毕还没有符合的字符，就返回-1。 时间复杂度：O(n)。遍历两次。2n。 空间复杂度：$O(|\\Sigma|)$，其中 $\\Sigma$ 是字符集，在本题中 s 只包含小写字母，因此 $|\\Sigma| \\leq 26$。我们需要 $O(|\\Sigma|)$的空间存储哈希映射。 1234567class Solution: def firstUniqChar(self, s: str) -&gt; int: co = collections.Counter(s) for i,x in enumerate(s): if co[x]==1: return i return -1 方法2、哈希表存储字符索引思路：构建空字典。第一次遍历，得到所有字符对应的索引。如果字符已存在于字典，对应字典值改为-1。 第二次遍历字典，直接返回第一个字典值不为-1的值。遍历完还没有符合的值，返回-1。 时间复杂度：同1 空间复杂度：同1 12345678910111213class Solution: def firstUniqChar(self, s: str) -&gt; int: # 哈希表存储字符索引 di = dict() for i,x in enumerate(s): if x in di: di[x]=-1 else: di[x]=i for k in di: if di[k] != -1: return di[k] return -1 方法3、队列队列的特点：先进先出。适合用来找第一次满足某个条件的元素。 思路：创建一个空字典和一个空队列。 遍历第一次，（只需要遍历一次） 如果字符不在字典中。字典存储字符和索引；二维队列存储字符和索引。 如果字符在字典中，字典字符的索引赋为-1，且二维队列中如字符存在队列首位，pop掉。 遍历完毕，输出队列首位的索引。 时间复杂度和空间复杂度同1。 1234567891011121314class Solution: def firstUniqChar(self, s: str) -&gt; int: # 哈希表存储字符索引, 队列存储索引，先进先出 di = dict() q = collections.deque() for i,x in enumerate(s): if x not in di: di[x] = i q.append((x,i)) else: di[x]=-1 while q and di[q[0][0]] == -1: q.popleft() return -1 if not q else q[0][1]","permalink":"https://yunbujian.github.io/2022/03/07/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","photos":[]},{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"13、整数反转","date":"2022/03/05","text":"题目描述给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123输出：321链接：https://leetcode-cn.com/problems/reverse-integer 错误案例123456789101112class Solution: def reverse(self, x: int) -&gt; int: a = 0 while x!=0: if x&lt;0: b = x % 10 - 10 # 想解决负数输入情况，但末尾=0时不行，见特殊情况 x = x // 10 + 1 # 想解决负数情况，但末尾=0时不行。 else: b = x % 10 x //= 10 a = a * 10 + b return a 注：/除法；//除法向下取整。 1423/10=142.3; 1423//10=142 特殊情况正数取余 % 返回末尾数字，如123%10=3；但负数取余 %，返回[0,9)数字，如-123%10=7。（想得到末尾-3，但是不能单纯的-10）。因为当末尾本身就是0，无论正负返回还是0。如-100%10=0。-10 就错了。 取模：% 返回除法的余数。 当数字&lt;0 and 末尾!=0时，-123%10-10=-3. 12345678910class Solution: def reverse(self, x: int) -&gt; int: a = 0 while x!=0: b = x % 10 if x&lt;0 and b != 0: # 负数，且末尾不为0时 b = x % 10 - 10 x = (x-b) // 10 # 取整。-b去掉末尾数的影响。 a = a * 10 + b return a 取整。-b去掉末尾数的影响：123//10=12; -123//10=-13（X）。去掉末尾数的影响，(123-3)//10=12; (-123-(-3))//10=-12。即(x-b) // 10 题中还有一个条件：超过 32 位的有符号整数的范围 [−2^31^, 2^31^ − 1] ，就返回 0。于是改进如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: MIN, MAX = -2**31, 2**31-1 a = 0 while x!=0: b = x % 10 if x&lt;0 and b != 0: b = x % 10 - 10 x = (x-b) // 10 a = a * 10 + b if a&lt;MIN or a&gt;MAX: # 判断有无超过32位 return 0 return a 但是环境不允许存储 64 位整数（有符号或无符号）。也就是说a已经超过了32位，不能直接存储并和MAX，MIN比较大小。 尽量不要对边界进行加减，以防越界。 123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: MIN, MAX = -2**31, 2**31-1 a = 0 while x!=0: b = x % 10 if a &gt; MAX//10 or (a == MAX//10 and b &gt; 7): # 只需要比较前九位 return 0 if a &lt; (MIN+8)//10 or (a == (MIN+8)//10 and b &lt; -8): # 负数向下取整的问题，排除末尾的影响。 return 0 if x&lt;0 and b != 0: b = x % 10 - 10 x = (x-b) // 10 a = a * 10 + b return a MIN = -2147483648 MAX = 2147483647 只需要比较：前九位。 时间复杂度：O(log|x|)。翻转次数即x十进制的位数。（看不懂…) 空间复杂度：O(1)","permalink":"https://yunbujian.github.io/2022/03/05/13.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","photos":[]},{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"12、反转字符串","date":"2022/03/04","text":"题目描述方法1、双指针我自己的思路：前后互换，遍历n//2次（向下取整）。其实就是双指针。 思路：发现规律。s[i] 的字符与 s[N - 1 - i] 的字符发生交换。 123456789class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; n = len(s) x = n//2 for i in range(x): s[i],s[n-1-i] = s[n-1-i],s[i] 或者直接逆向取值 s[:]=s[::-1]一行搞定 或者利用中间变量临时存储要反转的值。 12345678910111213class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; n = len(s) i = 0 while(i&lt;n-1): t = s[i] # 中间变量 s[i] = s[n-1] s[n-1] = t i += 1 n -= 1","permalink":"https://yunbujian.github.io/2022/03/04/12.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","photos":[]},{"tags":[{"name":"数组","slug":"数组","permalink":"https://yunbujian.github.io/tags/%E6%95%B0%E7%BB%84/"}],"title":"11、旋转图像","date":"2022/03/03","text":"题目描述方法1、使用辅助数组思路：找规律。发现第i行第j列数，旋转之后到达第j行倒数第i列。得到等式：$m[j][l-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。n为矩阵边长。 空间复杂度：O(n^2^)。需要构造辅助数组。 123456789101112class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # m = copy.deepcopy(matrix) # 深拷贝，改变新m不会导致同时改变原matrix l = len(matrix) m = [[0]*l for _ in range(l)] for i in range(l-1,-1,-1): for j in range(0,l): # 正向遍历 m[j][l-1-i] = matrix[i][j] # 找规律，第i行第j列的数正好转到了第j行倒数第i列 matrix[:] = m 方法2、原地旋转思路：观察关键等式：$m[j][l-i-1]=m[i][j]$，不断的旋转，得到 从下旋转到上，发现四个等式一循环。 $m[i][j]=m[l-j-1][i]$ $m[l-j-1][i]=m[l-i-1][l-j-1]$ $m[l-i-1][l-j-1]=m[j][l-i-1]$ $m[j][l-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。遍历$[n/2]*[(n+1)/2]=O(n^2)$ 空间复杂度：O(1)。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 原地旋转 n = len(matrix) for i in range(n//2): for j in range((n+1)//2): matrix[i][j], matrix[n-j-1][i], matrix[n-i-1][n-j-1], matrix[j][n-i-1] = matrix[n-j-1][i], matrix[n-i-1][n-j-1], matrix[j][n-i-1], matrix[i][j] 方法3、解压、逆序取值123456789class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 解压，相当于转置；然后每行逆序取值。 matrix[:] = list(zip(*matrix)) for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 示例： 123456&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*zipped) # *zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)] [::-1] 顺序相反操作，逆序取值 123a=&#x27;python&#x27;b=a[::-1]print(b) #nohtyp 方法4、水平翻转，对角线翻转思路：水平翻转：$m[n-i-1][j]=m[i][j]$ 主对角线翻转：$m[j][i]=m[i][j]$ 联立方程正好为关键等式：$m[j][n-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。每次翻转需要遍历一半的数。 空间复杂度：O(1)。 1234567891011121314class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 水平翻转，主对角线翻转，正好为关键等式。 n = len(matrix) for i in range(n//2): for j in range(n): matrix[n-i-1][j], matrix[i][j] = matrix[i][j], matrix[n-i-1][j] # 主对角线翻转 for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]","permalink":"https://yunbujian.github.io/2022/03/03/11.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","photos":[]},{"tags":[],"title":"10、轮转数组","date":"2022/03/02","text":"题目描述给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]链接：https://leetcode-cn.com/problems/rotate-array 方法1、三次反转思路： 运行时间：52ms 1234567891011121314151617class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 三次反转 &quot;&quot;&quot; n = len(nums) k = k%n def swap(l,r): while(l&lt;r): nums[l], nums[r] = nums[r], nums[l] l+=1 r-=1 swap(0,n-k-1) swap(n-k,n-1) swap(0,n-1) 2、用list的pop函数思路：pop掉最后一个数，再把该数insert到第一位。 运行时间：1860ms（很慢很慢） 12345678910class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 将最后一个数pop并插到第一位 &quot;&quot;&quot; n = len(nums) k%=n for _ in range(k): nums.insert(0, nums.pop()) 3、创建临时数据存放运行时间：40ms 12345678910111213class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 用临时数组new存放 &quot;&quot;&quot; new = nums.copy() # 不能直接赋值，会让nums和n一起变化 或直接 new=nums[:] l = len(nums) for i in range(l): k1 = (i+k)%l new[k1] = nums[i] for i in range(l): nums[i] = new[i] 4、拼接前后数组123456789class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 拼接前后数组 &quot;&quot;&quot; n = len(nums) k%=n nums[:] = nums[n-k:]+nums[:n-k]","permalink":"https://yunbujian.github.io/2022/03/02/10.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[],"title":"9、有效的数独","date":"2022/03/01","text":"题目描述请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。空白格用 ‘.’ 表示。 示例 1： 输入：board =[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：true链接：https://leetcode-cn.com/problems/valid-sudoku 方法1、哈希表、一次遍历思路：利用defaultdict(set)，建立一个哈希表，key为行or列；value是一个set，可以存放多个数据。 from collections import defaultdict r=defaultdict(set) key：0,1,2…表示第几行or第几列。 value为一个set，存放数据，若已存在相同数据，返回False。 时间复杂度：O(1)。对81个数遍历一次。 空间复杂度：O(1)。哈希表存放数据量固定。 注意：//: 返回商的整数部分，向下取整。数字在哪一块3x3 的宫内：i//3*3+j//3。 1234567891011121314151617class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row, col, sqrt = defaultdict(set), defaultdict(set), defaultdict(set) for i in range(9): for j in range(9): val = board[i][j] # 遍历所有的数 if val == &#x27;.&#x27;: continue # 跳过没有数的空格 point = i//3*3+j//3 if val in row[i] or val in col[j] or val in sqrt[point]: print(i,j,point) print(row,col,sqrt) return False row[i].add(val) col[j].add(val) sqrt[point].add(val) return True","permalink":"https://yunbujian.github.io/2022/03/01/9.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","photos":[]},{"tags":[],"title":"8、买卖股票的最佳时机 II","date":"2022/02/28","text":"题目描述给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。 在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。返回 你能获得的 最大 利润 。 示例 1: 输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii 方法1、贪心算法思路：判断后一天价格是否高于前一天，高，就卖。（有钱就卖，即大于0就卖。） 时间复杂度：O(n) 空间复杂度：O(1)。只需要存放常数个若干变量。 123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 收集所有上升时间段买卖（当然这是上帝视角了） l = len(prices) r = 0 for i in range(1, l): if prices[i] &gt; prices[i-1]: r += prices[i]-prices[i-1] return r 方法2、动态规划动态规划就是把大问题拆分成小问题，把几天的问题，拆分成一天一天的买和卖。 思路： 手里的股票分为，有股票和无股票。 时间分为数组长度l的天数。 新建一个二维数组，行=天数，列=有股票和无股票（两列）。 首先第一天，无股票收益 = 0；有股票收益 = -买入股票价格的支出。 之后的天数里： ​ 1、今天无股票的最大利润=max{昨天就无股票(利润保持不变)，昨天有股票+今天卖掉的收益} ​ 2、今天有股票的最大利润=max{昨天就有股票(利润保持不变)，昨天无股票-今天买进的支出} 最后返回最后一天无股票时候的价格。（有股票的收益一定小于无股票，如果最后一天还有股票，那么最后一天需要支出买入股票的价格，或者持有不动。） 时间复杂度：O(n)，n为数组长度。一共有2n个状态。每次状态转移的时间复杂度是O(1)，因此总的时间复杂度是O(2n)=O(n) 空间复杂度：O(n)。需要2n个空间存储所有状态，或者看代码二进行空间优化，只需要存昨天的两个值，复杂度降为O(1)。 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 动态规划 if not prices: return 0 l = len(prices) dp = [[0 for x in range(2)] for y in range(l)] dp[0][0] = 0 # 第一天无股票时的收益 dp[0][1] = -prices[0] # 第一天有股票时的收益 for i in range(1, l): dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) # 今天无股票的收益 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) # 今天有股票的收益 return dp[l-1][0] # 返回最后一天无股票的时候的收益 因为当前时刻的收益，只和昨天的有无股票有关，所以只需要存储昨天的值即可。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 动态规划, 只存储上一时刻的有无股票值 if not prices: return 0 l = len(prices) dp0 = 0 dp1 = -prices[0] for i in range(1, l): dp0 = max(dp0, dp1+prices[i]) dp1 = max(dp1, dp0-prices[i]) return dp0","permalink":"https://yunbujian.github.io/2022/02/28/8.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/","photos":[]},{"tags":[],"title":"7、删除有序数组中的重复项","date":"2022/02/26","text":"删除有序数组中的重复项题目描述给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 方法1、双指针法思路：fast、slow指针指向位置1。if fast与fast-1相等，fast++，跳过该重复的数； else fast与fast-1不相等，把fast数赋值给slow位置，slow++，fast++ 12345678910111213class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: l = len(nums) if not nums: return 0 fast = slow = 1 while fast &lt; l: # 只需要写一条fast+1就够了，因为每次都能执行到 if nums[fast] != nums[fast-1]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow # 为什么不是返回nums[:slow]? 官方会调用语句再次打印nums数组","permalink":"https://yunbujian.github.io/2022/02/26/7.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","photos":[]},{"tags":[],"title":"0. 怎么刷题？刷哪些题？","date":"2022/02/26","text":"怎么刷题？刷哪些题？刷题顺序真小白，（数据结构都不太熟悉的），先按照每个专题来刷简单题。以初级算法为例开始刷。 初级算法 - 力扣 而后刷力扣HOT 前100、前200。 HOT前100题-力扣 最后刷剑指offer。（75题） 剑指offer 力扣 刷每道题的步骤1、确定题目考察点数组查找计算，有可能是双指针，哈希，位运算，还可能是动态规划，贪心处理。要知道经典算法处理的哪些经典问题。 没思路？ 2、看相关标签 没思路？ 3、看提示 没思路？ 4、看题解看懂为止 5、编写代码、测试思路可以看，别人的代码也可以看，但自己写代码的时候不要参考和 ctrl c + ctrl v。 写完代码，用测试案例多测测，确保万无一失。力扣经常出空值测试案例，因为这个 wa 了很多次。 6、方法、结果对比不要以为 ac 了就完了，你要看看自己时间上超越了多少人，从两个维度衡量自己的代码： 要超越 70% 以上的人（根据自己要求适当提高）：大部分题超越 70% 说明方法上是没问题的。 另外，力扣你点击前面时间的柱状图是可以看到别人时间开销较小的代码（有的现在跑可能因为测试数据变动没那么快了），可以参考学习一下别人的处理方式。","permalink":"https://yunbujian.github.io/2022/02/26/0.%E6%80%8E%E4%B9%88%E5%88%B7%E9%A2%98%EF%BC%9F/","photos":[]},{"tags":[],"title":"6、移动零","date":"2022/02/26","text":"题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]链接：https://leetcode-cn.com/problems/move-zeroes 方法1、双指针思路：定义两个指针，left、right都指向数组开头。用right指针去遍历所有的数，当该数!=0时，right指向的数和left指的数互换，并且left+1，保证left左边的数都不为0（即left始终指向0）。 时间复杂度：O(n)，每个数最多被遍历2次。 空间复杂度：O(1)，只需要常数的空间存放数字。（数组长度） 123456789101112class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; l = len(nums) left = right = 0 while right&lt;l: if nums[right] != 0: nums[left], nums[right] = nums[right], nums[left] left += 1 right += 1 方法2、不为0的覆盖到最前面，最后补0思路：也是两个指针，不采用一个一个移动的方法，而是把不为0的直接覆盖到前面，最后遍历完一遍，后面补0。（我觉得方法1更优雅…) 时间复杂度：同1 空间复杂度：同1 123456789101112131415class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; l = len(nums) left = right = 0 while right &lt; l: if nums[right] != 0: nums[left] = nums[right] left += 1 right += 1 for i in range(left, l): nums[i]=0","permalink":"https://yunbujian.github.io/2022/02/26/6.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/","photos":[]},{"tags":[],"title":"加一","date":"2022/02/24","text":"方法1、考虑特殊情况，末尾是9思路： 1、末尾无9，直接+1；2、末尾多个9，找最前面不是9的数+1，之后的数置零；3、数组全是9，返回一个新数组，首位=1，其余=0 时间复杂度：O(n)O(n)，其中 nn 是数组 \\textit{digits}digits 的长度。 空间复杂度：O(1)O(1)。返回值不计入空间复杂度。 执行用时：32 ms 注意：逆序遍历，反序遍历 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: # 考虑特殊情况 l = len(digits) for i in range(l-1,-1,-1): if digits[i]!=9: digits[i]+=1 for j in range(i+1,l): digits[j]=0 return digits return [1]+[0]*l 方法2、余数（判断+1是否为0）思路：判断最后一个数+1求余数是否为0 1、逆序遍历求余数，赋值给当前位置；如不全为0，直接返回结果；2、如全为0，则返回多一位的新数组，首位=1，其余为0. 执行用时：36 ms 123456789class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: # 求余数 l = len(digits) for i in range(l-1,-1,-1): digits[i]=(digits[i]+1)%10 if digits[i]!=0: return digits return [1]+[0]*l","permalink":"https://yunbujian.github.io/2022/02/24/5.%E5%8A%A0%E4%B8%80/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"4.两个数组的交集Ⅱ","date":"2022/02/23","text":"题目描述给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1：输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 方法1、暴力解法思路：遍历nums1，判断各数是否存在于nums2，存在，存入结果，并把该数从nums2划掉；不存在，继续判断下一个数。 注意：从这个思路可以隐约感受到为什么哈希表法需要-1。 执行时间：60ms 时间复杂度：O(mn) 123456789class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 暴力解法 r=list() for i in nums1: if i in nums2: r.append(i) nums2.remove(i) return r 方法2、哈希表思路总结： 1、排序，先处理更短的list；2、new一个哈希表，存放数组1各数字出现的次数；（collections.Counter()即可实现）3、遍历数组2，如果哈希表存在该数，取出为输出结果；并且哈希表该数出现次数-1；如果出现次数=0了（没得减了），就pop掉该数。 为什么减1，我的理解是第一个数组遍历完，最多出现次数只能和数组1一致，多了也没用了 注意：:= 海象运算符。 执行用时：36 ms 时间复杂度：O(m+n)，m,n为两数组的长度，需遍历两数组并操作哈希表。哈希表操作时间复杂度为O(1) 空间复杂度：O(min(m,n))，哈希表不超过较短的list，返回结果的list也不超过较短的list。 1234567891011121314151617class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 哈希表 if len(nums1)&gt;len(nums2): return self.intersect(nums2, nums1) r = list() d = collections.Counter() # 也可以直接用d = collections.Counter(nums1) for num in nums1: d[num]+=1 for i in nums2: if (count := d.get(i,0)) &gt;0: r.append(i) d[i] -= 1 if d[i]==0: d.pop(i) return r 方法3、排序+双指针思路： 1、两数组先排序。2、设置两个指针分别对应两数组的头。3、从左往后依次判断是否相等，不相等，较小的那个数组指针+1。4、直到某一数组溢出，停止。 执行时间：40ms 时间复杂度：O(mlogm+nlogn)，排序需要O(mlogm+nlogn)，遍历两个数组需要O(m+n)。 空间复杂度：O(min(m,n))，返回结果的数组不超过较短的数组。 注意：推荐方法2，因为方法2的nums2只需查询操作，读取部分数据即可。 磁盘空间有限，而方法3排序需要加载nums2所有元素到内存中。 123456789101112131415161718class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 排序+双指针 nums1.sort() nums2.sort() len1, len2 = len(nums1), len(nums2) r = list() idx1=idx2=0 while idx1&lt;len1 and idx2&lt;len2: if nums1[idx1] &lt; nums2[idx2]: idx1 += 1 elif nums1[idx1] &gt; nums2[idx2]: idx2 += 1 else: r.append(nums1[idx1]) idx1 += 1 idx2 += 1 return r","permalink":"https://yunbujian.github.io/2022/02/23/4.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"3.存在重复元素","date":"2022/02/22","text":"题目描述给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1]输出：true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate 方法1、排序执行用时：88 ms 时间复杂度：O(nlogn) 空间复杂度：O(logn) 思路总结：先排序，遍历每个数，判断相邻的数是否相同。有相同，返回true；无，返回false。 注意：for循环要执行完毕，才能return false。 1234567891011class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; list.sort(nums) for i in range(len(nums)-1): if nums[i]==nums[i+1]: return True return False # 这里我犯错了 方法2、集合Set执行用时：48 ms 时间复杂度：O() 空间复杂度：O() 思路总结：利用set集合的不重复性，将数组转set，如果长度不一致，说明有重复的元素。 1234567891011class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; # return not len(set(nums))==len(nums) # 一行解决 40ms s = set(nums) if len(s) == len(nums): return False return True 也可以遍历数组，逐个存入空集合，如果已存在，表示有重复。32ms 同理，也可以构建一个hash表。 12345678910111213class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; s = set() for i in nums: if i in s: return True else: s.add(i) return False 方法3、哈希表执行用时： ms 时间复杂度：O() 空间复杂度：O() 思路总结：新建一个hash表，遍历数组，if hash表里存在相同的数，return True。 12345678910111213class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; hashtable = dict() for i in nums: if i in hashtable: return True else: hashtable[i]=1 # 随便赋一个值 return False","permalink":"https://yunbujian.github.io/2022/02/22/3.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"2.只出现一次的数字","date":"2022/02/20","text":"题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 。 链接：https://leetcode-cn.com/problems/single-number 方法1、集合set执行用时：32 ms 时间复杂度：O() 空间复杂度：O(n)，其中 n 是数组长度。 思路总结：使用集合存储数字。遍历数组，如果集合中存在该数，删除；如果不存在，加入。最后只剩下只出现一次的数，返回。 注意：利用set不能放重复元素的特性来做 1234567891011121314class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 暴力解法 1 &quot;&quot;&quot; s = set() for i, num in enumerate(nums): if num in s: s.remove(num) else: s.add(num) l=list(s) # 集合转换为列表是读取集合元素的必要步骤 return l[0] 方法2、哈希表执行用时： 28ms 时间复杂度：O() 空间复杂度：O(n) 思路总结：存入哈希表，key为数组的值，value为出现的次数。最后取出哈希表中次数（value）为1的key。 注意： 12345678910111213141516class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 哈希表 1 &quot;&quot;&quot; hashtable = dict() for i, num in enumerate(nums): if num in hashtable: hashtable[num] += 1 else: hashtable[num] = 1 for j in hashtable: if hashtable[j]==1: return j return 0 方法3、位运算，异或运算 ⊕执行用时： 24ms 时间复杂度：O(n) 空间复杂度：O(1) 思路总结：自身异或=0，与0异或=本身。重复的两个数先两两异或=0；再和只出现一次的数异或=只出现一次的数本身。 注意： 1234567class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 异或 1 &quot;&quot;&quot; return reduce(lambda x,y:x ^ y, nums) reduce()，对所有元素进行累积 方法4、求和相减执行用时： ms 时间复杂度：O() 空间复杂度：O() 思路总结：数组数据存入一个新的集合(集合不可重复)。对集合所有数据求和，再×2倍；对原数组所有数据求和。即set*2-list=只出现一次的数据。 注意： 12345678class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 求和相减 1 &quot;&quot;&quot; s = set(nums) return sum(s)*2-sum(nums)","permalink":"https://yunbujian.github.io/2022/02/20/2.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"1.两数之和","date":"2022/02/19","text":"题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 链接：https://leetcode-cn.com/problems/two-sum 方法1、暴力搜索执行用时：20 ms 时间复杂度：O(n^2) 空间复杂度：O(1) 思路总结：循环遍历两次list，分别判断相加是否为target。 注意：for循环需要range(len)，所以需要先得到list的len 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] nums=[2,7,11,15] :type target: int target = 9 :rtype: List[int] 暴力搜索 brute force way &quot;&quot;&quot; size = len(nums) for i in range(size): for j in range(i+1, size): if nums[i]+nums[j]==target: return [i,j] return [] 2、哈希表执行用时：16 ms 时间复杂度：O() 空间复杂度：O() 思路总结：构建hash表，如hash表中有target-num，直接取；如果没有，先存入。存入的hash表，key=数组的值；value=数组的下标。 注意：for循环需要range(len)，所以需要先得到list的len 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] nums=[2,7,11,15] :type target: int target = 9 :rtype: List[int] 哈希表 hash table &quot;&quot;&quot; hashtable = dict() # 构建hash table for i,num in enumerate(nums): if target - num in hashtable: return [hashtable[target-num], i] hashtable[nums[i]] = i return []","permalink":"https://yunbujian.github.io/2022/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"title":"短暂离家","date":"2022/02/17","text":"启程回学校。漫天雪飘，高速隧道。浪漫又凄凄。 舍不得啊！ 在学校，踩着九点早餐准时谢幕的档口，匆忙抢一些冷透了的牛肉包，就着速溶黑芝麻糊勉强入口。 在家里，虽然早午餐总是恰巧碰在了一起，但是每一次都有热腾腾的饭菜，忍不住多吃几碗吃一顿就少一顿的饭。 在学校想吃个水果吧，要骑着小电驴去北亭采购，纠结一番，选择的最佳标准就是: 不用剥皮，方便吃就行。 在家里，你会被建议吃一些复杂的水果，要剥皮？不存在的，只需要你点一点头，削好皮的水果就递在你眼前了，果核往桌上一放就会自动消失。 在学校泡脚这种复杂的活真是少见，烧水，备桶，加盐，兑冷水，时刻准备着加热…反正一年泡不到两次吧… 在家里，你会被提议泡个脚，只要你点一点头，在看电视的空挡，热腾腾的泡脚水不知什么时候已在脚边，实在是惭愧，自己才是那个“巨婴”吧。 妈妈睡眠不好，胃口极好。 我担心她，拖她去看睡眠障碍医生，又担心她日益见长的肚腩对膝盖沉重的负担，和她一起践行健康饮食，减少碳水，督促她每天做一分钟平板支撑。 妈妈说最近睡眠不错，没什么运动量也一直在平稳掉秤。 老爸牙疼，牙结石臭气熏天，我在试图说服他去洗个牙，但他有他的一套“处事准则”，不可轻易动摇。我用自己的洗牙体验，引经据典，旁敲侧击的告诉他洗牙的好处。 他在动摇，也许明年回来就要成功击溃他内心的城墙。 最喜欢的是不落雨的时候，一家人的默契是一定要出去散个步。 俺们家是犬系动物，非得出去溜溜，不然闷得慌。 踏着湖边的大好景色，一直走下去，永远不会腻。 湖景不像大海，大海是浅蓝浅蓝的，一眼望不到边。也不像深山里的九寨沟，是清澈见底的浅滩碧绿。千岛湖的水是望不穿的翡翠般的深绿，矮山远近重叠，小岛错落有致，夕阳打在上面是少女粉色的，粉的发紫。 小时候我总好奇，跑到湖边捧起一手，“翡翠”就不见了，只看得到清晰的掌纹。 按理来说，此情此景，从小在这长大的我早该厌倦了罢，就像厌倦了朝九晚五和一层不变的生活。 可偏偏是每望一次都有一次的欣喜和平静。这叫人如何舍得！ 不管自己多大，不管走的多远，在父母眼里始终是个生活不能自理，不会照顾自己的傻瓜。 感谢爸爸妈妈的温柔以待，以身作则，让我更加懂得如何照顾一个人，如果表达自然流露，奔涌而出，温润如水的爱意。","permalink":"https://yunbujian.github.io/2022/02/17/%E7%9F%AD%E6%9A%82%E7%A6%BB%E5%AE%B6/","photos":[]},{"tags":[],"title":"Hello World","date":"1999/02/19","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"https://yunbujian.github.io/1999/02/19/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"链表","slug":"链表","permalink":"https://yunbujian.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://yunbujian.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}]}