{"meta":{"title":"☁ YunBJ","subtitle":"Hi :)","description":"My Blog.","author":"云不见","url":"https://yunbujian.github.io","root":"/"},"posts":[{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"14、字符串中的第一个唯一字符","date":"2022/03/07","text":"题目描述给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。 示例 1：输入: s = “leetcode”输出: 0 示例 2:输入: s = “loveleetcode”输出: 2链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string 方法1、哈希表存储字符频次使用哈希表存储字符出现的次数。 思路：先遍历一次，得到所有字符出现的次数。（这个用内置函数collections.Counter()即可。） 再遍历一次，直接返回第一次出现1次的字符的索引。遍历完毕还没有符合的字符，就返回-1。 时间复杂度：O(n)。遍历两次。2n。 空间复杂度：$O(|\\Sigma|)$，其中 $\\Sigma$ 是字符集，在本题中 s 只包含小写字母，因此 $|\\Sigma| \\leq 26$。我们需要 $O(|\\Sigma|)$的空间存储哈希映射。 1234567class Solution: def firstUniqChar(self, s: str) -&gt; int: co = collections.Counter(s) for i,x in enumerate(s): if co[x]==1: return i return -1 方法2、哈希表存储字符索引思路：构建空字典。第一次遍历，得到所有字符对应的索引。如果字符已存在于字典，对应字典值改为-1。 第二次遍历字典，直接返回第一个字典值不为-1的值。遍历完还没有符合的值，返回-1。 时间复杂度：同1 空间复杂度：同1 12345678910111213class Solution: def firstUniqChar(self, s: str) -&gt; int: # 哈希表存储字符索引 di = dict() for i,x in enumerate(s): if x in di: di[x]=-1 else: di[x]=i for k in di: if di[k] != -1: return di[k] return -1 方法3、队列队列的特点：先进先出。适合用来找第一次满足某个条件的元素。 思路：创建一个空字典和一个空队列。 遍历第一次，（只需要遍历一次） 如果字符不在字典中。字典存储字符和索引；二维队列存储字符和索引。 如果字符在字典中，字典字符的索引赋为-1，且二维队列中如字符存在队列首位，pop掉。 遍历完毕，输出队列首位的索引。 时间复杂度和空间复杂度同1。 1234567891011121314class Solution: def firstUniqChar(self, s: str) -&gt; int: # 哈希表存储字符索引, 队列存储索引，先进先出 di = dict() q = collections.deque() for i,x in enumerate(s): if x not in di: di[x] = i q.append((x,i)) else: di[x]=-1 while q and di[q[0][0]] == -1: q.popleft() return -1 if not q else q[0][1]","permalink":"https://yunbujian.github.io/2022/03/07/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","photos":[]},{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"13、整数反转","date":"2022/03/05","text":"题目描述给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123输出：321链接：https://leetcode-cn.com/problems/reverse-integer 错误案例123456789101112class Solution: def reverse(self, x: int) -&gt; int: a = 0 while x!=0: if x&lt;0: b = x % 10 - 10 # 想解决负数输入情况，但末尾=0时不行，见特殊情况 x = x // 10 + 1 # 想解决负数情况，但末尾=0时不行。 else: b = x % 10 x //= 10 a = a * 10 + b return a 注：/除法；//除法向下取整。 1423/10=142.3; 1423//10=142 特殊情况正数取余 % 返回末尾数字，如123%10=3；但负数取余 %，返回[0,9)数字，如-123%10=7。（想得到末尾-3，但是不能单纯的-10）。因为当末尾本身就是0，无论正负返回还是0。如-100%10=0。-10 就错了。 取模：% 返回除法的余数。 当数字&lt;0 and 末尾!=0时，-123%10-10=-3. 12345678910class Solution: def reverse(self, x: int) -&gt; int: a = 0 while x!=0: b = x % 10 if x&lt;0 and b != 0: # 负数，且末尾不为0时 b = x % 10 - 10 x = (x-b) // 10 # 取整。-b去掉末尾数的影响。 a = a * 10 + b return a 取整。-b去掉末尾数的影响：123//10=12; -123//10=-13（X）。去掉末尾数的影响，(123-3)//10=12; (-123-(-3))//10=-12。即(x-b) // 10 题中还有一个条件：超过 32 位的有符号整数的范围 [−2^31^, 2^31^ − 1] ，就返回 0。于是改进如下： 12345678910111213class Solution: def reverse(self, x: int) -&gt; int: MIN, MAX = -2**31, 2**31-1 a = 0 while x!=0: b = x % 10 if x&lt;0 and b != 0: b = x % 10 - 10 x = (x-b) // 10 a = a * 10 + b if a&lt;MIN or a&gt;MAX: # 判断有无超过32位 return 0 return a 但是环境不允许存储 64 位整数（有符号或无符号）。也就是说a已经超过了32位，不能直接存储并和MAX，MIN比较大小。 尽量不要对边界进行加减，以防越界。 123456789101112131415class Solution: def reverse(self, x: int) -&gt; int: MIN, MAX = -2**31, 2**31-1 a = 0 while x!=0: b = x % 10 if a &gt; MAX//10 or (a == MAX//10 and b &gt; 7): # 只需要比较前九位 return 0 if a &lt; (MIN+8)//10 or (a == (MIN+8)//10 and b &lt; -8): # 负数向下取整的问题，排除末尾的影响。 return 0 if x&lt;0 and b != 0: b = x % 10 - 10 x = (x-b) // 10 a = a * 10 + b return a MIN = -2147483648 MAX = 2147483647 只需要比较：前九位。 时间复杂度：O(log|x|)。翻转次数即x十进制的位数。（看不懂…) 空间复杂度：O(1)","permalink":"https://yunbujian.github.io/2022/03/05/13.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","photos":[]},{"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"title":"12、反转字符串","date":"2022/03/04","text":"题目描述方法1、双指针我自己的思路：前后互换，遍历n//2次（向下取整）。其实就是双指针。 思路：发现规律。s[i] 的字符与 s[N - 1 - i] 的字符发生交换。 123456789class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; n = len(s) x = n//2 for i in range(x): s[i],s[n-1-i] = s[n-1-i],s[i] 或者直接逆向取值 s[:]=s[::-1]一行搞定 或者利用中间变量临时存储要反转的值。 12345678910111213class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; n = len(s) i = 0 while(i&lt;n-1): t = s[i] # 中间变量 s[i] = s[n-1] s[n-1] = t i += 1 n -= 1","permalink":"https://yunbujian.github.io/2022/03/04/12.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","photos":[]},{"tags":[{"name":"数组","slug":"数组","permalink":"https://yunbujian.github.io/tags/%E6%95%B0%E7%BB%84/"}],"title":"11、旋转图像","date":"2022/03/03","text":"题目描述方法1、使用辅助数组思路：找规律。发现第i行第j列数，旋转之后到达第j行倒数第i列。得到等式：$m[j][l-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。n为矩阵边长。 空间复杂度：O(n^2^)。需要构造辅助数组。 123456789101112class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # m = copy.deepcopy(matrix) # 深拷贝，改变新m不会导致同时改变原matrix l = len(matrix) m = [[0]*l for _ in range(l)] for i in range(l-1,-1,-1): for j in range(0,l): # 正向遍历 m[j][l-1-i] = matrix[i][j] # 找规律，第i行第j列的数正好转到了第j行倒数第i列 matrix[:] = m 方法2、原地旋转思路：观察关键等式：$m[j][l-i-1]=m[i][j]$，不断的旋转，得到 从下旋转到上，发现四个等式一循环。 $m[i][j]=m[l-j-1][i]$ $m[l-j-1][i]=m[l-i-1][l-j-1]$ $m[l-i-1][l-j-1]=m[j][l-i-1]$ $m[j][l-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。遍历$[n/2]*[(n+1)/2]=O(n^2)$ 空间复杂度：O(1)。 12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 原地旋转 n = len(matrix) for i in range(n//2): for j in range((n+1)//2): matrix[i][j], matrix[n-j-1][i], matrix[n-i-1][n-j-1], matrix[j][n-i-1] = matrix[n-j-1][i], matrix[n-i-1][n-j-1], matrix[j][n-i-1], matrix[i][j] 方法3、解压、逆序取值123456789class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 解压，相当于转置；然后每行逆序取值。 matrix[:] = list(zip(*matrix)) for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 示例： 123456&gt;&gt;&gt;a = [1,2,3]&gt;&gt;&gt; b = [4,5,6]&gt;&gt;&gt; zipped = zip(a,b) # 打包为元组的列表[(1, 4), (2, 5), (3, 6)]&gt;&gt;&gt; zip(*zipped) # *zipped 可理解为解压，返回二维矩阵式[(1, 2, 3), (4, 5, 6)] [::-1] 顺序相反操作，逆序取值 123a=&#x27;python&#x27;b=a[::-1]print(b) #nohtyp 方法4、水平翻转，对角线翻转思路：水平翻转：$m[n-i-1][j]=m[i][j]$ 主对角线翻转：$m[j][i]=m[i][j]$ 联立方程正好为关键等式：$m[j][n-i-1]=m[i][j]$ 时间复杂度：O(n^2^)。每次翻转需要遍历一半的数。 空间复杂度：O(1)。 1234567891011121314class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 水平翻转，主对角线翻转，正好为关键等式。 n = len(matrix) for i in range(n//2): for j in range(n): matrix[n-i-1][j], matrix[i][j] = matrix[i][j], matrix[n-i-1][j] # 主对角线翻转 for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]","permalink":"https://yunbujian.github.io/2022/03/03/11.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","photos":[]},{"tags":[],"title":"10、轮转数组","date":"2022/03/02","text":"题目描述给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]链接：https://leetcode-cn.com/problems/rotate-array 方法1、三次反转思路： 运行时间：52ms 1234567891011121314151617class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 三次反转 &quot;&quot;&quot; n = len(nums) k = k%n def swap(l,r): while(l&lt;r): nums[l], nums[r] = nums[r], nums[l] l+=1 r-=1 swap(0,n-k-1) swap(n-k,n-1) swap(0,n-1) 2、用list的pop函数思路：pop掉最后一个数，再把该数insert到第一位。 运行时间：1860ms（很慢很慢） 12345678910class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 将最后一个数pop并插到第一位 &quot;&quot;&quot; n = len(nums) k%=n for _ in range(k): nums.insert(0, nums.pop()) 3、创建临时数据存放运行时间：40ms 12345678910111213class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 用临时数组new存放 &quot;&quot;&quot; new = nums.copy() # 不能直接赋值，会让nums和n一起变化 或直接 new=nums[:] l = len(nums) for i in range(l): k1 = (i+k)%l new[k1] = nums[i] for i in range(l): nums[i] = new[i] 4、拼接前后数组123456789class Solution: def rotate(self, nums: List[int], k: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. 拼接前后数组 &quot;&quot;&quot; n = len(nums) k%=n nums[:] = nums[n-k:]+nums[:n-k]","permalink":"https://yunbujian.github.io/2022/03/02/10.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/","photos":[]},{"tags":[],"title":"9、有效的数独","date":"2022/03/01","text":"题目描述请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。空白格用 ‘.’ 表示。 示例 1： 输入：board =[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：true链接：https://leetcode-cn.com/problems/valid-sudoku 方法1、哈希表、一次遍历思路：利用defaultdict(set)，建立一个哈希表，key为行or列；value是一个set，可以存放多个数据。 from collections import defaultdict r=defaultdict(set) key：0,1,2…表示第几行or第几列。 value为一个set，存放数据，若已存在相同数据，返回False。 时间复杂度：O(1)。对81个数遍历一次。 空间复杂度：O(1)。哈希表存放数据量固定。 注意：//: 返回商的整数部分，向下取整。数字在哪一块3x3 的宫内：i//3*3+j//3。 1234567891011121314151617class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: row, col, sqrt = defaultdict(set), defaultdict(set), defaultdict(set) for i in range(9): for j in range(9): val = board[i][j] # 遍历所有的数 if val == &#x27;.&#x27;: continue # 跳过没有数的空格 point = i//3*3+j//3 if val in row[i] or val in col[j] or val in sqrt[point]: print(i,j,point) print(row,col,sqrt) return False row[i].add(val) col[j].add(val) sqrt[point].add(val) return True","permalink":"https://yunbujian.github.io/2022/03/01/9.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","photos":[]},{"tags":[],"title":"8、买卖股票的最佳时机 II","date":"2022/02/28","text":"题目描述给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。 在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。返回 你能获得的 最大 利润 。 示例 1: 输入: prices = [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii 方法1、贪心算法思路：判断后一天价格是否高于前一天，高，就卖。（有钱就卖，即大于0就卖。） 时间复杂度：O(n) 空间复杂度：O(1)。只需要存放常数个若干变量。 123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 收集所有上升时间段买卖（当然这是上帝视角了） l = len(prices) r = 0 for i in range(1, l): if prices[i] &gt; prices[i-1]: r += prices[i]-prices[i-1] return r 方法2、动态规划动态规划就是把大问题拆分成小问题，把几天的问题，拆分成一天一天的买和卖。 思路： 手里的股票分为，有股票和无股票。 时间分为数组长度l的天数。 新建一个二维数组，行=天数，列=有股票和无股票（两列）。 首先第一天，无股票收益 = 0；有股票收益 = -买入股票价格的支出。 之后的天数里： ​ 1、今天无股票的最大利润=max{昨天就无股票(利润保持不变)，昨天有股票+今天卖掉的收益} ​ 2、今天有股票的最大利润=max{昨天就有股票(利润保持不变)，昨天无股票-今天买进的支出} 最后返回最后一天无股票时候的价格。（有股票的收益一定小于无股票，如果最后一天还有股票，那么最后一天需要支出买入股票的价格，或者持有不动。） 时间复杂度：O(n)，n为数组长度。一共有2n个状态。每次状态转移的时间复杂度是O(1)，因此总的时间复杂度是O(2n)=O(n) 空间复杂度：O(n)。需要2n个空间存储所有状态，或者看代码二进行空间优化，只需要存昨天的两个值，复杂度降为O(1)。 12345678910111213class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 动态规划 if not prices: return 0 l = len(prices) dp = [[0 for x in range(2)] for y in range(l)] dp[0][0] = 0 # 第一天无股票时的收益 dp[0][1] = -prices[0] # 第一天有股票时的收益 for i in range(1, l): dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) # 今天无股票的收益 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) # 今天有股票的收益 return dp[l-1][0] # 返回最后一天无股票的时候的收益 因为当前时刻的收益，只和昨天的有无股票有关，所以只需要存储昨天的值即可。 123456789101112class Solution: def maxProfit(self, prices: List[int]) -&gt; int: # 动态规划, 只存储上一时刻的有无股票值 if not prices: return 0 l = len(prices) dp0 = 0 dp1 = -prices[0] for i in range(1, l): dp0 = max(dp0, dp1+prices[i]) dp1 = max(dp1, dp0-prices[i]) return dp0","permalink":"https://yunbujian.github.io/2022/02/28/8.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/","photos":[]},{"tags":[],"title":"7、删除有序数组中的重复项","date":"2022/02/26","text":"删除有序数组中的重复项题目描述给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。 由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。 将最终结果插入 nums 的前 k 个位置后返回 k 。 不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 判题标准: 系统会用下面的代码来测试你的题解: 123456789int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123; assert nums[i] == expectedNums[i];&#125; 如果所有断言都通过，那么您的题解将被 通过。 示例 1： 输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array 方法1、双指针法思路：fast、slow指针指向位置1。if fast与fast-1相等，fast++，跳过该重复的数； else fast与fast-1不相等，把fast数赋值给slow位置，slow++，fast++ 12345678910111213class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: l = len(nums) if not nums: return 0 fast = slow = 1 while fast &lt; l: # 只需要写一条fast+1就够了，因为每次都能执行到 if nums[fast] != nums[fast-1]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow # 为什么不是返回nums[:slow]? 官方会调用语句再次打印nums数组","permalink":"https://yunbujian.github.io/2022/02/26/7.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","photos":[]},{"tags":[],"title":"0. 怎么刷题？刷哪些题？","date":"2022/02/26","text":"怎么刷题？刷哪些题？刷题顺序真小白，（数据结构都不太熟悉的），先按照每个专题来刷简单题。以初级算法为例开始刷。 初级算法 - 力扣 而后刷力扣HOT 前100、前200。 HOT前100题-力扣 最后刷剑指offer。（75题） 剑指offer 力扣 刷每道题的步骤1、确定题目考察点数组查找计算，有可能是双指针，哈希，位运算，还可能是动态规划，贪心处理。要知道经典算法处理的哪些经典问题。 没思路？ 2、看相关标签 没思路？ 3、看提示 没思路？ 4、看题解看懂为止 5、编写代码、测试思路可以看，别人的代码也可以看，但自己写代码的时候不要参考和 ctrl c + ctrl v。 写完代码，用测试案例多测测，确保万无一失。力扣经常出空值测试案例，因为这个 wa 了很多次。 6、方法、结果对比不要以为 ac 了就完了，你要看看自己时间上超越了多少人，从两个维度衡量自己的代码： 要超越 70% 以上的人（根据自己要求适当提高）：大部分题超越 70% 说明方法上是没问题的。 另外，力扣你点击前面时间的柱状图是可以看到别人时间开销较小的代码（有的现在跑可能因为测试数据变动没那么快了），可以参考学习一下别人的处理方式。","permalink":"https://yunbujian.github.io/2022/02/26/0.%E6%80%8E%E4%B9%88%E5%88%B7%E9%A2%98%EF%BC%9F/","photos":[]},{"tags":[],"title":"6、移动零","date":"2022/02/26","text":"题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]链接：https://leetcode-cn.com/problems/move-zeroes 方法1、双指针思路：定义两个指针，left、right都指向数组开头。用right指针去遍历所有的数，当该数!=0时，right指向的数和left指的数互换，并且left+1，保证left左边的数都不为0（即left始终指向0）。 时间复杂度：O(n)，每个数最多被遍历2次。 空间复杂度：O(1)，只需要常数的空间存放数字。（数组长度） 123456789101112class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; l = len(nums) left = right = 0 while right&lt;l: if nums[right] != 0: nums[left], nums[right] = nums[right], nums[left] left += 1 right += 1 方法2、不为0的覆盖到最前面，最后补0思路：也是两个指针，不采用一个一个移动的方法，而是把不为0的直接覆盖到前面，最后遍历完一遍，后面补0。（我觉得方法1更优雅…) 时间复杂度：同1 空间复杂度：同1 123456789101112131415class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; l = len(nums) left = right = 0 while right &lt; l: if nums[right] != 0: nums[left] = nums[right] left += 1 right += 1 for i in range(left, l): nums[i]=0","permalink":"https://yunbujian.github.io/2022/02/26/6.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/","photos":[]},{"tags":[],"title":"加一","date":"2022/02/24","text":"方法1、考虑特殊情况，末尾是9思路： 1、末尾无9，直接+1；2、末尾多个9，找最前面不是9的数+1，之后的数置零；3、数组全是9，返回一个新数组，首位=1，其余=0 时间复杂度：O(n)O(n)，其中 nn 是数组 \\textit{digits}digits 的长度。 空间复杂度：O(1)O(1)。返回值不计入空间复杂度。 执行用时：32 ms 注意：逆序遍历，反序遍历 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: # 考虑特殊情况 l = len(digits) for i in range(l-1,-1,-1): if digits[i]!=9: digits[i]+=1 for j in range(i+1,l): digits[j]=0 return digits return [1]+[0]*l 方法2、余数（判断+1是否为0）思路：判断最后一个数+1求余数是否为0 1、逆序遍历求余数，赋值给当前位置；如不全为0，直接返回结果；2、如全为0，则返回多一位的新数组，首位=1，其余为0. 执行用时：36 ms 123456789class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: # 求余数 l = len(digits) for i in range(l-1,-1,-1): digits[i]=(digits[i]+1)%10 if digits[i]!=0: return digits return [1]+[0]*l","permalink":"https://yunbujian.github.io/2022/02/24/5.%E5%8A%A0%E4%B8%80/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"4.两个数组的交集Ⅱ","date":"2022/02/23","text":"题目描述给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1：输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 方法1、暴力解法思路：遍历nums1，判断各数是否存在于nums2，存在，存入结果，并把该数从nums2划掉；不存在，继续判断下一个数。 注意：从这个思路可以隐约感受到为什么哈希表法需要-1。 执行时间：60ms 时间复杂度：O(mn) 123456789class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 暴力解法 r=list() for i in nums1: if i in nums2: r.append(i) nums2.remove(i) return r 方法2、哈希表思路总结： 1、排序，先处理更短的list；2、new一个哈希表，存放数组1各数字出现的次数；（collections.Counter()即可实现）3、遍历数组2，如果哈希表存在该数，取出为输出结果；并且哈希表该数出现次数-1；如果出现次数=0了（没得减了），就pop掉该数。 为什么减1，我的理解是第一个数组遍历完，最多出现次数只能和数组1一致，多了也没用了 注意：:= 海象运算符。 执行用时：36 ms 时间复杂度：O(m+n)，m,n为两数组的长度，需遍历两数组并操作哈希表。哈希表操作时间复杂度为O(1) 空间复杂度：O(min(m,n))，哈希表不超过较短的list，返回结果的list也不超过较短的list。 1234567891011121314151617class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 哈希表 if len(nums1)&gt;len(nums2): return self.intersect(nums2, nums1) r = list() d = collections.Counter() # 也可以直接用d = collections.Counter(nums1) for num in nums1: d[num]+=1 for i in nums2: if (count := d.get(i,0)) &gt;0: r.append(i) d[i] -= 1 if d[i]==0: d.pop(i) return r 方法3、排序+双指针思路： 1、两数组先排序。2、设置两个指针分别对应两数组的头。3、从左往后依次判断是否相等，不相等，较小的那个数组指针+1。4、直到某一数组溢出，停止。 执行时间：40ms 时间复杂度：O(mlogm+nlogn)，排序需要O(mlogm+nlogn)，遍历两个数组需要O(m+n)。 空间复杂度：O(min(m,n))，返回结果的数组不超过较短的数组。 注意：推荐方法2，因为方法2的nums2只需查询操作，读取部分数据即可。 磁盘空间有限，而方法3排序需要加载nums2所有元素到内存中。 123456789101112131415161718class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: # 排序+双指针 nums1.sort() nums2.sort() len1, len2 = len(nums1), len(nums2) r = list() idx1=idx2=0 while idx1&lt;len1 and idx2&lt;len2: if nums1[idx1] &lt; nums2[idx2]: idx1 += 1 elif nums1[idx1] &gt; nums2[idx2]: idx2 += 1 else: r.append(nums1[idx1]) idx1 += 1 idx2 += 1 return r","permalink":"https://yunbujian.github.io/2022/02/23/4.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"3.存在重复元素","date":"2022/02/22","text":"题目描述给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 示例 1： 输入：nums = [1,2,3,1]输出：true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/contains-duplicate 方法1、排序执行用时：88 ms 时间复杂度：O(nlogn) 空间复杂度：O(logn) 思路总结：先排序，遍历每个数，判断相邻的数是否相同。有相同，返回true；无，返回false。 注意：for循环要执行完毕，才能return false。 1234567891011class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; list.sort(nums) for i in range(len(nums)-1): if nums[i]==nums[i+1]: return True return False # 这里我犯错了 方法2、集合Set执行用时：48 ms 时间复杂度：O() 空间复杂度：O() 思路总结：利用set集合的不重复性，将数组转set，如果长度不一致，说明有重复的元素。 1234567891011class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; # return not len(set(nums))==len(nums) # 一行解决 40ms s = set(nums) if len(s) == len(nums): return False return True 也可以遍历数组，逐个存入空集合，如果已存在，表示有重复。32ms 同理，也可以构建一个hash表。 12345678910111213class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; s = set() for i in nums: if i in s: return True else: s.add(i) return False 方法3、哈希表执行用时： ms 时间复杂度：O() 空间复杂度：O() 思路总结：新建一个hash表，遍历数组，if hash表里存在相同的数，return True。 12345678910111213class Solution(object): def containsDuplicate(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: bool &quot;&quot;&quot; hashtable = dict() for i in nums: if i in hashtable: return True else: hashtable[i]=1 # 随便赋一个值 return False","permalink":"https://yunbujian.github.io/2022/02/22/3.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"2.只出现一次的数字","date":"2022/02/20","text":"题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 。 链接：https://leetcode-cn.com/problems/single-number 方法1、集合set执行用时：32 ms 时间复杂度：O() 空间复杂度：O(n)，其中 n 是数组长度。 思路总结：使用集合存储数字。遍历数组，如果集合中存在该数，删除；如果不存在，加入。最后只剩下只出现一次的数，返回。 注意：利用set不能放重复元素的特性来做 1234567891011121314class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 暴力解法 1 &quot;&quot;&quot; s = set() for i, num in enumerate(nums): if num in s: s.remove(num) else: s.add(num) l=list(s) # 集合转换为列表是读取集合元素的必要步骤 return l[0] 方法2、哈希表执行用时： 28ms 时间复杂度：O() 空间复杂度：O(n) 思路总结：存入哈希表，key为数组的值，value为出现的次数。最后取出哈希表中次数（value）为1的key。 注意： 12345678910111213141516class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 哈希表 1 &quot;&quot;&quot; hashtable = dict() for i, num in enumerate(nums): if num in hashtable: hashtable[num] += 1 else: hashtable[num] = 1 for j in hashtable: if hashtable[j]==1: return j return 0 方法3、位运算，异或运算 ⊕执行用时： 24ms 时间复杂度：O(n) 空间复杂度：O(1) 思路总结：自身异或=0，与0异或=本身。重复的两个数先两两异或=0；再和只出现一次的数异或=只出现一次的数本身。 注意： 1234567class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 异或 1 &quot;&quot;&quot; return reduce(lambda x,y:x ^ y, nums) reduce()，对所有元素进行累积 方法4、求和相减执行用时： ms 时间复杂度：O() 空间复杂度：O() 思路总结：数组数据存入一个新的集合(集合不可重复)。对集合所有数据求和，再×2倍；对原数组所有数据求和。即set*2-list=只出现一次的数据。 注意： 12345678class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] [2,2,1] :rtype: int 求和相减 1 &quot;&quot;&quot; s = set(nums) return sum(s)*2-sum(nums)","permalink":"https://yunbujian.github.io/2022/02/20/2.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","photos":[]},{"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"}],"title":"1.两数之和","date":"2022/02/19","text":"题目描述给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 链接：https://leetcode-cn.com/problems/two-sum 方法1、暴力搜索执行用时：20 ms 时间复杂度：O(n^2) 空间复杂度：O(1) 思路总结：循环遍历两次list，分别判断相加是否为target。 注意：for循环需要range(len)，所以需要先得到list的len 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] nums=[2,7,11,15] :type target: int target = 9 :rtype: List[int] 暴力搜索 brute force way &quot;&quot;&quot; size = len(nums) for i in range(size): for j in range(i+1, size): if nums[i]+nums[j]==target: return [i,j] return [] 2、哈希表执行用时：16 ms 时间复杂度：O() 空间复杂度：O() 思路总结：构建hash表，如hash表中有target-num，直接取；如果没有，先存入。存入的hash表，key=数组的值；value=数组的下标。 注意：for循环需要range(len)，所以需要先得到list的len 12345678910111213class Solution(object): def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] nums=[2,7,11,15] :type target: int target = 9 :rtype: List[int] 哈希表 hash table &quot;&quot;&quot; hashtable = dict() # 构建hash table for i,num in enumerate(nums): if target - num in hashtable: return [hashtable[target-num], i] hashtable[nums[i]] = i return []","permalink":"https://yunbujian.github.io/2022/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","photos":[]},{"tags":[{"name":"随笔","slug":"随笔","permalink":"https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"}],"title":"短暂离家","date":"2022/02/17","text":"启程回学校。漫天雪飘，高速隧道。浪漫又凄凄。 舍不得啊！ 在学校，踩着九点早餐准时谢幕的档口，匆忙抢一些冷透了的牛肉包，就着速溶黑芝麻糊勉强入口。 在家里，虽然早午餐总是恰巧碰在了一起，但是每一次都有热腾腾的饭菜，忍不住多吃几碗吃一顿就少一顿的饭。 在学校想吃个水果吧，要骑着小电驴去北亭采购，纠结一番，选择的最佳标准就是: 不用剥皮，方便吃就行。 在家里，你会被建议吃一些复杂的水果，要剥皮？不存在的，只需要你点一点头，削好皮的水果就递在你眼前了，果核往桌上一放就会自动消失。 在学校泡脚这种复杂的活真是少见，烧水，备桶，加盐，兑冷水，时刻准备着加热…反正一年泡不到两次吧… 在家里，你会被提议泡个脚，只要你点一点头，在看电视的空挡，热腾腾的泡脚水不知什么时候已在脚边，实在是惭愧，自己才是那个“巨婴”吧。 妈妈睡眠不好，胃口极好。 我担心她，拖她去看睡眠障碍医生，又担心她日益见长的肚腩对膝盖沉重的负担，和她一起践行健康饮食，减少碳水，督促她每天做一分钟平板支撑。 妈妈说最近睡眠不错，没什么运动量也一直在平稳掉秤。 老爸牙疼，牙结石臭气熏天，我在试图说服他去洗个牙，但他有他的一套“处事准则”，不可轻易动摇。我用自己的洗牙体验，引经据典，旁敲侧击的告诉他洗牙的好处。 他在动摇，也许明年回来就要成功击溃他内心的城墙。 最喜欢的是不落雨的时候，一家人的默契是一定要出去散个步。 俺们家是犬系动物，非得出去溜溜，不然闷得慌。 踏着湖边的大好景色，一直走下去，永远不会腻。 湖景不像大海，大海是浅蓝浅蓝的，一眼望不到边。也不像深山里的九寨沟，是清澈见底的浅滩碧绿。千岛湖的水是望不穿的翡翠般的深绿，矮山远近重叠，小岛错落有致，夕阳打在上面是少女粉色的，粉的发紫。 小时候我总好奇，跑到湖边捧起一手，“翡翠”就不见了，只看得到清晰的掌纹。 按理来说，此情此景，从小在这长大的我早该厌倦了罢，就像厌倦了朝九晚五和一层不变的生活。 可偏偏是每望一次都有一次的欣喜和平静。这叫人如何舍得！ 不管自己多大，不管走的多远，在父母眼里始终是个生活不能自理，不会照顾自己的傻瓜。 感谢爸爸妈妈的温柔以待，以身作则，让我更加懂得如何照顾一个人，如果表达自然流露，奔涌而出，温润如水的爱意。","permalink":"https://yunbujian.github.io/2022/02/17/%E7%9F%AD%E6%9A%82%E7%A6%BB%E5%AE%B6/","photos":[]},{"tags":[],"title":"Hello World","date":"1999/02/19","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","permalink":"https://yunbujian.github.io/1999/02/19/hello-world/","photos":[]}],"categories":[],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","permalink":"https://yunbujian.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://yunbujian.github.io/tags/LeetCode/"},{"name":"随笔","slug":"随笔","permalink":"https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}