<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>☁ YunBJ</title>
  
  <subtitle>Hi :)</subtitle>
  <link href="https://yunbujian.github.io/atom.xml" rel="self"/>
  
  <link href="https://yunbujian.github.io/"/>
  <updated>2022-03-07T02:55:27.092Z</updated>
  <id>https://yunbujian.github.io/</id>
  
  <author>
    <name>云不见</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>14、字符串中的第一个唯一字符</title>
    <link href="https://yunbujian.github.io/2022/03/07/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/"/>
    <id>https://yunbujian.github.io/2022/03/07/14.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</id>
    <published>2022-03-07T01:06:01.407Z</published>
    <updated>2022-03-07T02:55:27.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个字符串 s ，找到 它的<strong>第一个不重复的字符</strong>，并返回它的索引 。如果不存在，则返回 -1 。</p><p>示例 1：<br>输入: s = “leetcode”<br>输出: 0</p><p>示例 2:<br>输入: s = “loveleetcode”<br>输出: 2<br>链接：<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">https://leetcode-cn.com/problems/first-unique-character-in-a-string</a></p><h2 id="方法1、哈希表存储字符频次"><a href="#方法1、哈希表存储字符频次" class="headerlink" title="方法1、哈希表存储字符频次"></a>方法1、哈希表存储字符频次</h2><p>使用哈希表存储字符出现的次数。</p><p>思路：先遍历一次，得到所有字符出现的次数。（这个用内置函数<code>collections.Counter()</code>即可。）</p><p>再遍历一次，直接返回第一次出现1次的字符的索引。遍历完毕还没有符合的字符，就返回-1。</p><p>时间复杂度：O(n)。遍历两次。2n。</p><p>空间复杂度：$O(|\Sigma|)$，其中 $\Sigma$ 是字符集，在本题中 s 只包含小写字母，因此 $|\Sigma| \leq 26$。我们需要 $O(|\Sigma|)$的空间存储哈希映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        co = collections.Counter(s)</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> co[x]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="方法2、哈希表存储字符索引"><a href="#方法2、哈希表存储字符索引" class="headerlink" title="方法2、哈希表存储字符索引"></a>方法2、哈希表存储字符索引</h2><p>思路：构建空字典。第一次遍历，得到所有字符对应的索引。如果字符已存在于字典，对应字典值改为-1。</p><p>第二次遍历字典，直接返回第一个字典值不为-1的值。遍历完还没有符合的值，返回-1。</p><p>时间复杂度：同1</p><p>空间复杂度：同1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希表存储字符索引</span></span><br><span class="line">        di = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> di:</span><br><span class="line">                di[x]=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                di[x]=i</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> di:</span><br><span class="line">            <span class="keyword">if</span> di[k] != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> di[k]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="方法3、队列"><a href="#方法3、队列" class="headerlink" title="方法3、队列"></a>方法3、队列</h2><p>队列的特点：先进先出。适合用来找第一次满足某个条件的元素。</p><p>思路：创建一个空字典和一个空队列。</p><p>遍历第一次，（只需要遍历一次）</p><p>如果字符不在字典中。字典存储字符和索引；二维队列存储字符和索引。</p><p>如果字符在字典中，字典字符的索引赋为-1，且二维队列中如字符存在队列首位，pop掉。</p><p>遍历完毕，输出队列首位的索引。</p><p>时间复杂度和空间复杂度同1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 哈希表存储字符索引, 队列存储索引，先进先出</span></span><br><span class="line">        di = <span class="built_in">dict</span>()</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i,x <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> di:</span><br><span class="line">                di[x] = i</span><br><span class="line">                q.append((x,i))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                di[x]=-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> q <span class="keyword">and</span> di[q[<span class="number">0</span>][<span class="number">0</span>]] == -<span class="number">1</span>:</span><br><span class="line">                    q.popleft()</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> q <span class="keyword">else</span> q[<span class="number">0</span>][<span class="number">1</span>]    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个字符串 s ，找到 它的&lt;strong&gt;第一个不重复的字符&lt;/strong&gt;，并返回它的索引 。如果不存在，则返回 </summary>
      
    
    
    
    
    <category term="字符串" scheme="https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>13、整数反转</title>
    <link href="https://yunbujian.github.io/2022/03/05/13.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
    <id>https://yunbujian.github.io/2022/03/05/13.%20%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</id>
    <published>2022-03-05T11:45:41.263Z</published>
    <updated>2022-03-06T13:20:17.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数<strong>超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</strong></p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><p>输入：x = 123<br>输出：321<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer">https://leetcode-cn.com/problems/reverse-integer</a></p><h3 id="错误案例"><a href="#错误案例" class="headerlink" title="错误案例"></a>错误案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">                b = x % <span class="number">10</span> - <span class="number">10</span>  <span class="comment"># 想解决负数输入情况，但末尾=0时不行，见特殊情况</span></span><br><span class="line">                x = x // <span class="number">10</span> + <span class="number">1</span>  <span class="comment"># 想解决负数情况，但末尾=0时不行。</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = x % <span class="number">10</span></span><br><span class="line">                x //= <span class="number">10</span></span><br><span class="line">            a = a * <span class="number">10</span> + b </span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>注：/除法；//除法向下取整。 1423/10=142.3; 1423//10=142</p><h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>正数取余 % 返回末尾数字，如123%10=3；但负数取余 %，返回[0,9)数字，如-123%10=7。（想得到末尾-3，但是不能单纯的-10）。因为当末尾本身就是0，无论正负返回还是0。如-100%10=0。-10 就错了。</p><p>取模：% 返回除法的余数。</p><p>当数字&lt;0 and 末尾!=0时，-123%10-10=-3.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            b = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">and</span> b != <span class="number">0</span>:  <span class="comment"># 负数，且末尾不为0时</span></span><br><span class="line">                b = x % <span class="number">10</span> - <span class="number">10</span></span><br><span class="line">            x = (x-b) // <span class="number">10</span>  <span class="comment"># 取整。-b去掉末尾数的影响。</span></span><br><span class="line">            a = a * <span class="number">10</span> + b </span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>取整。-b去掉末尾数的影响：123//10=12; -123//10=-13（X）。<strong>去掉末尾数的影响</strong>，(123-3)//10=12; (-123-(-3))//10=-12。即(x-b) // 10</p><p>题中还有一个条件：超过 32 位的有符号整数的范围 [−2^31^,  2^31^ − 1] ，就返回 0。于是改进如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN, MAX = -<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            b = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">and</span> b != <span class="number">0</span>: </span><br><span class="line">                b = x % <span class="number">10</span> - <span class="number">10</span></span><br><span class="line">            x = (x-b) // <span class="number">10</span> </span><br><span class="line">            a = a * <span class="number">10</span> + b </span><br><span class="line">        <span class="keyword">if</span> a&lt;MIN <span class="keyword">or</span> a&gt;MAX:  <span class="comment"># 判断有无超过32位</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>但是环境不允许存储 64 位整数（有符号或无符号）。也就是说<strong>a已经超过了32位，不能直接存储并和MAX，MIN比较大小。</strong></p><p>尽量不要对边界进行加减，以防越界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        MIN, MAX = -<span class="number">2</span>**<span class="number">31</span>, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x!=<span class="number">0</span>:</span><br><span class="line">            b = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> a &gt; MAX//<span class="number">10</span> <span class="keyword">or</span> (a == MAX//<span class="number">10</span> <span class="keyword">and</span> b &gt; <span class="number">7</span>):  <span class="comment"># 只需要比较前九位</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> a &lt; (MIN+<span class="number">8</span>)//<span class="number">10</span> <span class="keyword">or</span> (a == (MIN+<span class="number">8</span>)//<span class="number">10</span> <span class="keyword">and</span> b &lt; -<span class="number">8</span>):  <span class="comment"># 负数向下取整的问题，排除末尾的影响。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">and</span> b != <span class="number">0</span>:</span><br><span class="line">                b = x % <span class="number">10</span> - <span class="number">10</span></span><br><span class="line">            x = (x-b) // <span class="number">10</span></span><br><span class="line">            a = a * <span class="number">10</span> + b </span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p>MIN = -2147483648</p><p>MAX = 2147483647</p><p>只需要比较：前九位。</p><p>时间复杂度：O(log|x|)。翻转次数即x十进制的位数。（看不懂…)</p><p>空间复杂度：O(1)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数&lt;strong&gt;超</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>12、反转字符串</title>
    <link href="https://yunbujian.github.io/2022/03/04/12.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://yunbujian.github.io/2022/03/04/12.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-03-04T02:08:58.458Z</published>
    <updated>2022-03-04T03:07:57.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="方法1、双指针"><a href="#方法1、双指针" class="headerlink" title="方法1、双指针"></a>方法1、双指针</h2><p>我自己的思路：前后互换，遍历n//2次（向下取整）。其实就是双指针。</p><p>思路：发现规律。<code>s[i]</code> 的字符与 <code>s[N - 1 - i]</code> 的字符发生交换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        x = n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x):</span><br><span class="line">            s[i],s[n-<span class="number">1</span>-i] = s[n-<span class="number">1</span>-i],s[i]</span><br></pre></td></tr></table></figure><p>或者直接逆向取值</p><p><code>s[:]=s[::-1]</code>一行搞定</p><p>或者利用中间变量临时存储要反转的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n-<span class="number">1</span>):</span><br><span class="line">            t = s[i]  <span class="comment"># 中间变量</span></span><br><span class="line">            s[i] = s[n-<span class="number">1</span>]</span><br><span class="line">            s[n-<span class="number">1</span>] = t</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;方法1、双指针&quot;&gt;&lt;a href=&quot;#方法1、双指针&quot; class=&quot;headerlink&quot; title=&quot;方法1</summary>
      
    
    
    
    
    <category term="字符串" scheme="https://yunbujian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>11、旋转图像</title>
    <link href="https://yunbujian.github.io/2022/03/03/11.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <id>https://yunbujian.github.io/2022/03/03/11.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</id>
    <published>2022-03-03T05:30:11.970Z</published>
    <updated>2022-03-03T06:15:12.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="方法1、使用辅助数组"><a href="#方法1、使用辅助数组" class="headerlink" title="方法1、使用辅助数组"></a>方法1、使用辅助数组</h2><p>思路：找规律。发现第i行第j列数，旋转之后到达第j行倒数第i列。得到等式：$m[j][l-i-1]=m[i][j]$</p><p>时间复杂度：O(n^2^)。n为矩阵边长。</p><p>空间复杂度：O(n^2^)。需要构造辅助数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># m = copy.deepcopy(matrix)  # 深拷贝，改变新m不会导致同时改变原matrix</span></span><br><span class="line">        l = <span class="built_in">len</span>(matrix)</span><br><span class="line">        m = [[<span class="number">0</span>]*l <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,l):  <span class="comment"># 正向遍历</span></span><br><span class="line">                m[j][l-<span class="number">1</span>-i] = matrix[i][j]  <span class="comment"># 找规律，第i行第j列的数正好转到了第j行倒数第i列</span></span><br><span class="line">        matrix[:] = m</span><br></pre></td></tr></table></figure><h2 id="方法2、原地旋转"><a href="#方法2、原地旋转" class="headerlink" title="方法2、原地旋转"></a>方法2、原地旋转</h2><p>思路：观察关键等式：$m[j][l-i-1]=m[i][j]$，不断的旋转，得到</p><p>从下旋转到上，发现四个等式一循环。</p><p>$m[i][j]=m[l-j-1][i]$</p><p>$m[l-j-1][i]=m[l-i-1][l-j-1]$</p><p>$m[l-i-1][l-j-1]=m[j][l-i-1]$</p><p>$m[j][l-i-1]=m[i][j]$</p><p>时间复杂度：O(n^2^)。遍历$[n/2]*[(n+1)/2]=O(n^2)$</p><p>空间复杂度：O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 原地旋转</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">                matrix[i][j], matrix[n-j-<span class="number">1</span>][i], matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>], matrix[j][n-i-<span class="number">1</span>] = matrix[n-j-<span class="number">1</span>][i], matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>], matrix[j][n-i-<span class="number">1</span>], matrix[i][j]</span><br></pre></td></tr></table></figure><p><img src="C:/Users/walkontheway/AppData/Roaming/Typora/typora-user-images/image-20220303135441950.png" alt="image-20220303135441950"></p><h2 id="方法3、解压、逆序取值"><a href="#方法3、解压、逆序取值" class="headerlink" title="方法3、解压、逆序取值"></a>方法3、解压、逆序取值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 解压，相当于转置；然后每行逆序取值。</span></span><br><span class="line">        matrix[:] = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">            matrix[i] = matrix[i][::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1,2,3]</span><br><span class="line">&gt;&gt;&gt; b = [4,5,6]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; zip(*zipped)          # *zipped 可理解为解压，返回二维矩阵式</span><br><span class="line">[(1, 2, 3), (4, 5, 6)]</span><br></pre></td></tr></table></figure><p>[::-1] 顺序相反操作，逆序取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&#x27;python&#x27;</span></span><br><span class="line">b=a[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">#nohtyp</span></span><br></pre></td></tr></table></figure><h2 id="方法4、水平翻转，对角线翻转"><a href="#方法4、水平翻转，对角线翻转" class="headerlink" title="方法4、水平翻转，对角线翻转"></a>方法4、水平翻转，对角线翻转</h2><p>思路：水平翻转：$m[n-i-1][j]=m[i][j]$</p><p>主对角线翻转：$m[j][i]=m[i][j]$</p><p>联立方程正好为关键等式：$m[j][n-i-1]=m[i][j]$</p><p>时间复杂度：O(n^2^)。每次翻转需要遍历一半的数。</p><p>空间复杂度：O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 水平翻转，主对角线翻转，正好为关键等式。</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][j], matrix[i][j] = matrix[i][j], matrix[n-i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="comment"># 主对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;方法1、使用辅助数组&quot;&gt;&lt;a href=&quot;#方法1、使用辅助数组&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="数组" scheme="https://yunbujian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>10、轮转数组</title>
    <link href="https://yunbujian.github.io/2022/03/02/10.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <id>https://yunbujian.github.io/2022/03/02/10.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</id>
    <published>2022-03-02T01:52:45.279Z</published>
    <updated>2022-03-02T02:23:45.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><p>输入: nums = [1,2,3,4,5,6,7], k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>链接：<a href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a></p><h2 id="方法1、三次反转"><a href="#方法1、三次反转" class="headerlink" title="方法1、三次反转"></a>方法1、三次反转</h2><p>思路：</p><p>运行时间：52ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        三次反转</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k = k%n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">l,r</span>):</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r):</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        swap(<span class="number">0</span>,n-k-<span class="number">1</span>)</span><br><span class="line">        swap(n-k,n-<span class="number">1</span>)</span><br><span class="line">        swap(<span class="number">0</span>,n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="2、用list的pop函数"><a href="#2、用list的pop函数" class="headerlink" title="2、用list的pop函数"></a>2、用list的pop函数</h2><p>思路：pop掉最后一个数，再把该数insert到第一位。</p><p>运行时间：1860ms（很慢很慢）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        将最后一个数pop并插到第一位</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k%=n</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            nums.insert(<span class="number">0</span>, nums.pop())</span><br></pre></td></tr></table></figure><h2 id="3、创建临时数据存放"><a href="#3、创建临时数据存放" class="headerlink" title="3、创建临时数据存放"></a>3、创建临时数据存放</h2><p>运行时间：40ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        用临时数组new存放</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        new = nums.copy()  <span class="comment"># 不能直接赋值，会让nums和n一起变化 或直接 new=nums[:]</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            k1 = (i+k)%l</span><br><span class="line">            new[k1] = nums[i]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            nums[i] = new[i]          </span><br></pre></td></tr></table></figure><h2 id="4、拼接前后数组"><a href="#4、拼接前后数组" class="headerlink" title="4、拼接前后数组"></a>4、拼接前后数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        拼接前后数组</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k%=n</span><br><span class="line">        nums[:] = nums[n-k:]+nums[:n-k]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: nu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>9、有效的数独</title>
    <link href="https://yunbujian.github.io/2022/03/01/9.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    <id>https://yunbujian.github.io/2022/03/01/9.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</id>
    <published>2022-03-01T03:02:45.167Z</published>
    <updated>2022-03-01T08:18:04.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p><p>注意：</p><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>空白格用 ‘.’ 表示。</p><img src="C:/Users/walkontheway/AppData/Roaming/Typora/typora-user-images/image-20220301160146362.png" alt="image-20220301160146362" style="zoom:50%;" /><p>示例 1：</p><p>输入：board =<br>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：true<br>链接：<a href="https://leetcode-cn.com/problems/valid-sudoku">https://leetcode-cn.com/problems/valid-sudoku</a></p><h2 id="方法1、哈希表、一次遍历"><a href="#方法1、哈希表、一次遍历" class="headerlink" title="方法1、哈希表、一次遍历"></a>方法1、哈希表、一次遍历</h2><p>思路：利用defaultdict(set)，建立一个哈希表，key为行or列；value是一个set，可以存放多个数据。</p><p><code>from collections import defaultdict</code></p><p><code>r=defaultdict(set)</code></p><p>key：0,1,2…表示第几行or第几列。</p><p>value为一个set，存放数据，若已存在相同数据，返回False。</p><p>时间复杂度：O(1)。对81个数遍历一次。</p><p>空间复杂度：O(1)。哈希表存放数据量固定。</p><p>注意：//: 返回商的整数部分，向下取整。数字在哪一块3x3 的宫内：i//3*3+j//3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        row, col, sqrt = defaultdict(<span class="built_in">set</span>), defaultdict(<span class="built_in">set</span>), defaultdict(<span class="built_in">set</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                val = board[i][j]  <span class="comment"># 遍历所有的数</span></span><br><span class="line">                <span class="keyword">if</span> val == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span>  <span class="comment"># 跳过没有数的空格</span></span><br><span class="line">                point = i//<span class="number">3</span>*<span class="number">3</span>+j//<span class="number">3</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> row[i] <span class="keyword">or</span> val <span class="keyword">in</span> col[j] <span class="keyword">or</span> val <span class="keyword">in</span> sqrt[point]:</span><br><span class="line">                    <span class="built_in">print</span>(i,j,point)</span><br><span class="line">                    <span class="built_in">print</span>(row,col,sqrt)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                row[i].add(val)</span><br><span class="line">                col[j].add(val)</span><br><span class="line">                sqrt[point].add(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。&lt;/p&gt;
&lt;p&gt;数字 1-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>8、买卖股票的最佳时机 II</title>
    <link href="https://yunbujian.github.io/2022/02/28/8.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/"/>
    <id>https://yunbujian.github.io/2022/02/28/8.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</id>
    <published>2022-02-28T02:46:27.951Z</published>
    <updated>2022-03-01T07:05:38.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p><p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以购买它，然后在 同一天 出售。<br>返回 你能获得的 最大 利润 。</p><p>示例 1:</p><p>输入: prices = [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br>链接：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a></p><h2 id="方法1、贪心算法"><a href="#方法1、贪心算法" class="headerlink" title="方法1、贪心算法"></a>方法1、贪心算法</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>判断后一天价格是否高于前一天，高，就卖。（有钱就卖，即大于0就卖。）</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)。只需要存放常数个若干变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 收集所有上升时间段买卖（当然这是上帝视角了）</span></span><br><span class="line">        l = <span class="built_in">len</span>(prices)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i-<span class="number">1</span>]:</span><br><span class="line">                r += prices[i]-prices[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h2 id="方法2、动态规划"><a href="#方法2、动态规划" class="headerlink" title="方法2、动态规划"></a>方法2、动态规划</h2><p>动态规划就是把大问题拆分成小问题，把几天的问题，拆分成一天一天的买和卖。</p><p>思路：</p><p>手里的股票分为，有股票和无股票。</p><p>时间分为数组长度l的天数。</p><p>新建一个二维数组，行=天数，列=有股票和无股票（两列）。</p><p>首先第一天，无股票收益 = 0；有股票收益 = -买入股票价格的支出。</p><p>之后的天数里：</p><p>​    1、今天无股票的最大利润=max{昨天就无股票(利润保持不变)，昨天有股票+今天卖掉的收益}</p><p>​    2、今天有股票的最大利润=max{昨天就有股票(利润保持不变)，昨天无股票-今天买进的支出}</p><p>最后返回最后一天无股票时候的价格。（有股票的收益一定小于无股票，如果最后一天还有股票，那么最后一天需要支出买入股票的价格，或者持有不动。）</p><p>时间复杂度：O(n)，n为数组长度。一共有2n个状态。每次状态转移的时间复杂度是O(1)，因此总的时间复杂度是O(2n)=O(n)</p><p>空间复杂度：O(n)。需要2n个空间存储所有状态，或者看代码二进行空间优化，只需要存昨天的两个值，复杂度降为O(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(l)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>  <span class="comment"># 第一天无股票时的收益</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]  <span class="comment"># 第一天有股票时的收益</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i])  <span class="comment"># 今天无股票的收益</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])  <span class="comment"># 今天有股票的收益</span></span><br><span class="line">        <span class="keyword">return</span> dp[l-<span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># 返回最后一天无股票的时候的收益</span></span><br></pre></td></tr></table></figure><p>因为当前时刻的收益，只和昨天的有无股票有关，所以只需要存储昨天的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划, 只存储上一时刻的有无股票值</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp0 = <span class="number">0</span></span><br><span class="line">        dp1 = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp0, dp1+prices[i])</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0-prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;在每一天，你可能会决定购买</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>7、删除有序数组中的重复项</title>
    <link href="https://yunbujian.github.io/2022/02/26/7.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>https://yunbujian.github.io/2022/02/26/7.%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2022-02-26T13:30:30.318Z</published>
    <updated>2022-02-28T05:09:39.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 通过。</p><p>示例 1：</p><p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a></p><h3 id="方法1、双指针法"><a href="#方法1、双指针法" class="headerlink" title="方法1、双指针法"></a>方法1、双指针法</h3><p>思路：fast、slow指针指向位置1。if fast与fast-1相等，fast++，跳过该重复的数；</p><p>else fast与fast-1不相等，把fast数赋值给slow位置，slow++，fast++</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        fast = slow = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; l:  <span class="comment"># 只需要写一条fast+1就够了，因为每次都能执行到</span></span><br><span class="line">            <span class="keyword">if</span> nums[fast] != nums[fast-<span class="number">1</span>]:</span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow  <span class="comment"># 为什么不是返回nums[:slow]?</span></span><br></pre></td></tr></table></figure><p>官方会调用语句再次打印nums数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;删除有序数组中的重复项&quot;&gt;&lt;a href=&quot;#删除有序数组中的重复项&quot; class=&quot;headerlink&quot; title=&quot;删除有序数组中的重复项&quot;&gt;&lt;/a&gt;删除有序数组中的重复项&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>0. 怎么刷题？刷哪些题？</title>
    <link href="https://yunbujian.github.io/2022/02/26/0.%E6%80%8E%E4%B9%88%E5%88%B7%E9%A2%98%EF%BC%9F/"/>
    <id>https://yunbujian.github.io/2022/02/26/0.%E6%80%8E%E4%B9%88%E5%88%B7%E9%A2%98%EF%BC%9F/</id>
    <published>2022-02-26T12:47:19.870Z</published>
    <updated>2022-02-26T13:13:20.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎么刷题？刷哪些题？"><a href="#怎么刷题？刷哪些题？" class="headerlink" title="怎么刷题？刷哪些题？"></a>怎么刷题？刷哪些题？</h1><h2 id="刷题顺序"><a href="#刷题顺序" class="headerlink" title="刷题顺序"></a>刷题顺序</h2><p>真小白，（数据结构都不太熟悉的），先按照每个专题来刷简单题。以初级算法为例开始刷。</p><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2i30g/">初级算法 - 力扣</a></p><p>而后刷力扣HOT 前100、前200。</p><p><a href="https://leetcode-cn.com/problem-list/2cktkvj/">HOT前100题-力扣</a></p><p>最后刷剑指offer。（75题）</p><p><a href="https://leetcode-cn.com/problem-list/xb9nqhhg/">剑指offer 力扣</a></p><h2 id="刷每道题的步骤"><a href="#刷每道题的步骤" class="headerlink" title="刷每道题的步骤"></a>刷每道题的步骤</h2><h3 id="1、确定题目考察点"><a href="#1、确定题目考察点" class="headerlink" title="1、确定题目考察点"></a>1、确定题目考察点</h3><p>数组查找计算，有可能是双指针，哈希，位运算，还可能是动态规划，贪心处理。要知道经典算法处理的哪些经典问题。</p><p>没思路？</p><h3 id="2、看相关标签"><a href="#2、看相关标签" class="headerlink" title="2、看相关标签"></a>2、看相关标签</h3><p><img src="C:/Users/walkontheway/AppData/Roaming/Typora/typora-user-images/image-20220226210625052.png" alt="image-20220226210625052"></p><p>没思路？</p><h3 id="3、看提示"><a href="#3、看提示" class="headerlink" title="3、看提示"></a>3、看提示</h3><p><img src="C:/Users/walkontheway/AppData/Roaming/Typora/typora-user-images/image-20220226210728293.png" alt="image-20220226210728293"></p><p>没思路？</p><h3 id="4、看题解"><a href="#4、看题解" class="headerlink" title="4、看题解"></a>4、看题解</h3><p>看懂为止</p><h3 id="5、编写代码、测试"><a href="#5、编写代码、测试" class="headerlink" title="5、编写代码、测试"></a>5、编写代码、测试</h3><p>思路可以看，别人的代码也可以看，但自己写代码的时候不要参考和 ctrl c + ctrl v。</p><p>写完代码，用测试案例多测测，确保万无一失。力扣经常出空值测试案例，因为这个 wa 了很多次。</p><h3 id="6、方法、结果对比"><a href="#6、方法、结果对比" class="headerlink" title="6、方法、结果对比"></a>6、方法、结果对比</h3><p>不要以为 ac 了就完了，你要看看自己时间上超越了多少人，从两个维度衡量自己的代码：</p><p>要超越 70% 以上的人（根据自己要求适当提高）：大部分题超越 70% 说明方法上是没问题的。</p><p>另外，力扣你点击前面时间的柱状图是可以看到别人<strong>时间开销较小</strong>的代码（有的现在跑可能因为测试数据变动没那么快了），可以参考学习一下别人的处理方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;怎么刷题？刷哪些题？&quot;&gt;&lt;a href=&quot;#怎么刷题？刷哪些题？&quot; class=&quot;headerlink&quot; title=&quot;怎么刷题？刷哪些题？&quot;&gt;&lt;/a&gt;怎么刷题？刷哪些题？&lt;/h1&gt;&lt;h2 id=&quot;刷题顺序&quot;&gt;&lt;a href=&quot;#刷题顺序&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6、移动零</title>
    <link href="https://yunbujian.github.io/2022/02/26/6.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <id>https://yunbujian.github.io/2022/02/26/6.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/</id>
    <published>2022-02-26T12:16:59.679Z</published>
    <updated>2022-02-26T12:39:36.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例 1:</p><p>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>链接：<a href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a></p><h2 id="方法1、双指针"><a href="#方法1、双指针" class="headerlink" title="方法1、双指针"></a>方法1、双指针</h2><p>思路：定义两个指针，left、right都指向数组开头。用right指针去遍历所有的数，当该数!=0时，right指向的数和left指的数互换，并且left+1，保证left左边的数都不为0（即left始终指向0）。</p><p>时间复杂度：O(n)，每个数最多被遍历2次。</p><p>空间复杂度：O(1)，只需要常数的空间存放数字。（数组长度）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;l:</span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="方法2、不为0的覆盖到最前面，最后补0"><a href="#方法2、不为0的覆盖到最前面，最后补0" class="headerlink" title="方法2、不为0的覆盖到最前面，最后补0"></a>方法2、不为0的覆盖到最前面，最后补0</h2><p>思路：也是两个指针，不采用一个一个移动的方法，而是把不为0的直接覆盖到前面，最后遍历完一遍，后面补0。（我觉得方法1更优雅…)</p><p>时间复杂度：同1</p><p>空间复杂度：同1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; l:</span><br><span class="line">            <span class="keyword">if</span> nums[right] != <span class="number">0</span>:</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, l):</span><br><span class="line">            nums[i]=<span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;请注意 ，必须</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>加一</title>
    <link href="https://yunbujian.github.io/2022/02/24/5.%E5%8A%A0%E4%B8%80/"/>
    <id>https://yunbujian.github.io/2022/02/24/5.%E5%8A%A0%E4%B8%80/</id>
    <published>2022-02-24T02:37:53.247Z</published>
    <updated>2022-03-03T04:40:02.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法1、考虑特殊情况，末尾是9"><a href="#方法1、考虑特殊情况，末尾是9" class="headerlink" title="方法1、考虑特殊情况，末尾是9"></a>方法1、考虑特殊情况，末尾是9</h2><p>思路：</p><p>1、末尾无9，直接+1；<br>2、末尾多个9，找最前面不是9的数+1，之后的数置零；<br>3、数组全是9，返回一个新数组，首位=1，其余=0</p><p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{digits}digits 的长度。</p><p>空间复杂度：O(1)O(1)。返回值不计入空间复杂度。</p><p>执行用时：32 ms</p><p>注意：逆序遍历，反序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 考虑特殊情况 </span></span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> digits[i]!=<span class="number">9</span>:</span><br><span class="line">                digits[i]+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,l):</span><br><span class="line">                    digits[j]=<span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>]+[<span class="number">0</span>]*l</span><br></pre></td></tr></table></figure><h2 id="方法2、余数（判断-1是否为0）"><a href="#方法2、余数（判断-1是否为0）" class="headerlink" title="方法2、余数（判断+1是否为0）"></a>方法2、余数（判断+1是否为0）</h2><p>思路：判断最后一个数+1求余数是否为0</p><p>1、逆序遍历求余数，赋值给当前位置；如不全为0，直接返回结果；<br>2、如全为0，则返回多一位的新数组，首位=1，其余为0.</p><p>执行用时：36 ms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 求余数</span></span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            digits[i]=(digits[i]+<span class="number">1</span>)%<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> digits[i]!=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">1</span>]+[<span class="number">0</span>]*l</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法1、考虑特殊情况，末尾是9&quot;&gt;&lt;a href=&quot;#方法1、考虑特殊情况，末尾是9&quot; class=&quot;headerlink&quot; title=&quot;方法1、考虑特殊情况，末尾是9&quot;&gt;&lt;/a&gt;方法1、考虑特殊情况，末尾是9&lt;/h2&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;1、末尾无9，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>4.两个数组的交集Ⅱ</title>
    <link href="https://yunbujian.github.io/2022/02/23/4.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/"/>
    <id>https://yunbujian.github.io/2022/02/23/4.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/</id>
    <published>2022-02-22T16:00:00.000Z</published>
    <updated>2022-02-23T02:34:26.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><p>示例 1：<br>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2,2]<br>链接：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a></p><h2 id="方法1、暴力解法"><a href="#方法1、暴力解法" class="headerlink" title="方法1、暴力解法"></a>方法1、暴力解法</h2><p>思路：遍历nums1，判断各数是否存在于nums2，存在，存入结果，并把该数从nums2划掉；不存在，继续判断下一个数。</p><p>注意：从这个思路可以隐约感受到为什么哈希表法需要-1。</p><p>执行时间：60ms</p><p>时间复杂度：O(mn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 暴力解法</span></span><br><span class="line">        r=<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">                r.append(i)</span><br><span class="line">                nums2.remove(i)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h2 id="方法2、哈希表"><a href="#方法2、哈希表" class="headerlink" title="方法2、哈希表"></a>方法2、哈希表</h2><p>思路总结：</p><p>1、排序，先处理更短的list；<br>2、new一个哈希表，存放数组1各数字出现的次数；（collections.Counter()即可实现）<br>3、遍历数组2，如果哈希表存在该数，取出为输出结果；并且哈希表该数出现次数-1；如果出现次数=0了（没得减了），就pop掉该数。</p><p>为什么减1，我的理解是第一个数组遍历完，最多出现次数只能和数组1一致，多了也没用了</p><p>注意：:= 海象运算符。</p><p><strong>执行用时：36 ms</strong></p><p>时间复杂度：O(m+n)，m,n为两数组的长度，需遍历两数组并操作哈希表。哈希表操作时间复杂度为O(1)</p><p>空间复杂度：O(min(m,n))，哈希表不超过较短的list，返回结果的list也不超过较短的list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 哈希表</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1)&gt;<span class="built_in">len</span>(nums2):</span><br><span class="line">            <span class="keyword">return</span> self.intersect(nums2, nums1)</span><br><span class="line">        r = <span class="built_in">list</span>()</span><br><span class="line">        d = collections.Counter()  </span><br><span class="line">        <span class="comment"># 也可以直接用d = collections.Counter(nums1)</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums1:</span><br><span class="line">            d[num]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> (count := d.get(i,<span class="number">0</span>)) &gt;<span class="number">0</span>:</span><br><span class="line">                r.append(i)</span><br><span class="line">                d[i] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[i]==<span class="number">0</span>:</span><br><span class="line">                    d.pop(i)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><h2 id="方法3、排序-双指针"><a href="#方法3、排序-双指针" class="headerlink" title="方法3、排序+双指针"></a>方法3、排序+双指针</h2><p>思路：</p><p>1、两数组先排序。<br>2、设置两个指针分别对应两数组的头。<br>3、从左往后依次判断是否相等，不相等，较小的那个数组指针+1。<br>4、直到某一数组溢出，停止。</p><p>执行时间：40ms</p><p>时间复杂度：O(mlogm+nlogn)，排序需要O(mlogm+nlogn)，遍历两个数组需要O(m+n)。</p><p>空间复杂度：O(min(m,n))，返回结果的数组不超过较短的数组。</p><p>注意：推荐方法2，因为方法2的nums2只需查询操作，读取部分数据即可。</p><p>磁盘空间有限，而方法3排序需要加载nums2所有元素到内存中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersect</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 排序+双指针</span></span><br><span class="line">        nums1.sort()</span><br><span class="line">        nums2.sort()</span><br><span class="line">        len1, len2 = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        r = <span class="built_in">list</span>()</span><br><span class="line">        idx1=idx2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx1&lt;len1 <span class="keyword">and</span> idx2&lt;len2:</span><br><span class="line">            <span class="keyword">if</span> nums1[idx1] &lt; nums2[idx2]:</span><br><span class="line">                idx1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[idx1] &gt; nums2[idx2]:</span><br><span class="line">                idx2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r.append(nums1[idx1])</span><br><span class="line">                idx1 += <span class="number">1</span></span><br><span class="line">                idx2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://yunbujian.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>3.存在重复元素</title>
    <link href="https://yunbujian.github.io/2022/02/22/3.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://yunbujian.github.io/2022/02/22/3.%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2022-02-21T16:00:00.000Z</published>
    <updated>2022-02-23T02:03:51.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。</p><p>示例 1：</p><p>输入：nums = [1,2,3,1]<br>输出：true</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate">https://leetcode-cn.com/problems/contains-duplicate</a></p><h2 id="方法1、排序"><a href="#方法1、排序" class="headerlink" title="方法1、排序"></a>方法1、排序</h2><p><strong>执行用时：88 ms</strong></p><p>时间复杂度：O(nlogn)</p><p>空间复杂度：O(logn)</p><p>思路总结：先排序，遍历每个数，判断相邻的数是否相同。<strong>有相同，返回true</strong>；无，返回false。</p><p>注意：for循环要执行完毕，才能return false。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">list</span>.sort(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># 这里我犯错了</span></span><br></pre></td></tr></table></figure><h2 id="方法2、集合Set"><a href="#方法2、集合Set" class="headerlink" title="方法2、集合Set"></a>方法2、集合Set</h2><p><strong>执行用时：48 ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O()</p><p>思路总结：利用set集合的不重复性，将数组转set，如果长度不一致，说明有重复的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># return not len(set(nums))==len(nums) # 一行解决 40ms</span></span><br><span class="line">        s = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>也可以遍历数组，逐个存入空集合，如果已存在，表示有重复。32ms</p><p>同理，也可以构建一个hash表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="方法3、哈希表"><a href="#方法3、哈希表" class="headerlink" title="方法3、哈希表"></a>方法3、哈希表</h2><p><strong>执行用时： ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O()</p><p>思路总结：新建一个hash表，遍历数组，if hash表里存在相同的数，return True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[i]=<span class="number">1</span>  <span class="comment"># 随便赋一个值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 fal</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://yunbujian.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>2.只出现一次的数字</title>
    <link href="https://yunbujian.github.io/2022/02/20/2.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://yunbujian.github.io/2022/02/20/2.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2022-02-19T16:00:00.000Z</published>
    <updated>2022-02-20T13:10:39.518Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1] 输出: 1 。</p><p>链接：<a href="https://leetcode-cn.com/problems/single-number">https://leetcode-cn.com/problems/single-number</a></p><h3 id="方法1、集合set"><a href="#方法1、集合set" class="headerlink" title="方法1、集合set"></a>方法1、集合set</h3><p><strong>执行用时：32 ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O(n)，其中 n 是数组长度。</p><p>思路总结：使用集合存储数字。遍历数组，如果集合中存在该数，删除；如果不存在，加入。最后只剩下只出现一次的数，返回。</p><p>注意：利用set不能放重复元素的特性来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]  [2,2,1]</span></span><br><span class="line"><span class="string">        :rtype: int  暴力解法    1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> s:</span><br><span class="line">                s.remove(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s.add(num)</span><br><span class="line">        l=<span class="built_in">list</span>(s)  <span class="comment"># 集合转换为列表是读取集合元素的必要步骤</span></span><br><span class="line">        <span class="keyword">return</span> l[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="方法2、哈希表"><a href="#方法2、哈希表" class="headerlink" title="方法2、哈希表"></a>方法2、哈希表</h3><p><strong>执行用时： 28ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O(n)</p><p>思路总结：存入哈希表，key为数组的值，value为出现的次数。最后取出哈希表中次数（value）为1的key。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]  [2,2,1]</span></span><br><span class="line"><span class="string">        :rtype: int  哈希表     1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> hashtable:</span><br><span class="line">                hashtable[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashtable[num] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> hashtable:</span><br><span class="line">            <span class="keyword">if</span> hashtable[j]==<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> j</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="方法3、位运算，异或运算-⊕"><a href="#方法3、位运算，异或运算-⊕" class="headerlink" title="方法3、位运算，异或运算 ⊕"></a>方法3、位运算，异或运算 ⊕</h3><p><strong>执行用时： 24ms</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><p>思路总结：自身异或=0，与0异或=本身。重复的两个数先两两异或=0；再和只出现一次的数异或=只出现一次的数本身。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]  [2,2,1]</span></span><br><span class="line"><span class="string">        :rtype: int  异或     1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x,y:x ^ y, nums)</span><br></pre></td></tr></table></figure><p>reduce()，对所有元素进行累积</p><h3 id="方法4、求和相减"><a href="#方法4、求和相减" class="headerlink" title="方法4、求和相减"></a>方法4、求和相减</h3><p><strong>执行用时：  ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O()</p><p>思路总结：数组数据存入一个新的集合(集合不可重复)。对集合所有数据求和，再×2倍；对原数组所有数据求和。即set*2-list=只出现一次的数据。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]  [2,2,1]</span></span><br><span class="line"><span class="string">        :rtype: int   求和相减    1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(s)*<span class="number">2</span>-<span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;说明：</summary>
      
    
    
    
    <category term="blog" scheme="https://yunbujian.github.io/categories/blog/"/>
    
    
    <category term="LeetCode" scheme="https://yunbujian.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>1.两数之和</title>
    <link href="https://yunbujian.github.io/2022/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://yunbujian.github.io/2022/02/19/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2022-02-18T16:00:00.000Z</published>
    <updated>2022-02-21T12:58:37.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 </p><p>链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a></p><h3 id="方法1、暴力搜索"><a href="#方法1、暴力搜索" class="headerlink" title="方法1、暴力搜索"></a>方法1、暴力搜索</h3><p><strong>执行用时：20 ms</strong></p><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(1)</p><p>思路总结：循环遍历两次list，分别判断相加是否为target。</p><p>注意：for循环需要range(len)，所以需要先得到list的len</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]   nums=[2,7,11,15]</span></span><br><span class="line"><span class="string">        :type target: int       target = 9</span></span><br><span class="line"><span class="string">        :rtype: List[int]       暴力搜索 brute force way</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, size):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]==target:</span><br><span class="line">                    <span class="keyword">return</span> [i,j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h3 id="2、哈希表"><a href="#2、哈希表" class="headerlink" title="2、哈希表"></a>2、哈希表</h3><p><strong>执行用时：16 ms</strong></p><p>时间复杂度：O()</p><p>空间复杂度：O()</p><p>思路总结：构建hash表，如hash表中有target-num，直接取；如果没有，先存入。存入的hash表，key=数组的值；value=数组的下标。</p><p>注意：for循环需要range(len)，所以需要先得到list的len</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]   nums=[2,7,11,15]</span></span><br><span class="line"><span class="string">        :type target: int       target = 9</span></span><br><span class="line"><span class="string">        :rtype: List[int]       哈希表 hash table</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()  <span class="comment"># 构建hash table</span></span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> [hashtable[target-num], i]</span><br><span class="line">            hashtable[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，</summary>
      
    
    
    
    <category term="blog" scheme="https://yunbujian.github.io/categories/blog/"/>
    
    
    <category term="LeetCode" scheme="https://yunbujian.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>短暂离家</title>
    <link href="https://yunbujian.github.io/2022/02/17/%E7%9F%AD%E6%9A%82%E7%A6%BB%E5%AE%B6/"/>
    <id>https://yunbujian.github.io/2022/02/17/%E7%9F%AD%E6%9A%82%E7%A6%BB%E5%AE%B6/</id>
    <published>2022-02-16T16:00:00.000Z</published>
    <updated>2022-02-21T12:58:25.167Z</updated>
    
    <content type="html"><![CDATA[<p>启程回学校。漫天雪飘，高速隧道。浪漫又凄凄。</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/dCwhicdySicfPT9CJAIic13O8JPj75F1TKpzDeOZVXs8AyA6vNZCS1BpFhMeFTc2432vUgAfIdvqXazmpHicnSvNww/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>舍不得啊！</p><p>在学校，踩着九点早餐准时谢幕的档口，匆忙抢一些冷透了的牛肉包，就着速溶黑芝麻糊勉强入口。</p><p>在家里，虽然早午餐总是恰巧碰在了一起，但是每一次都有热腾腾的饭菜，忍不住多吃几碗吃一顿就少一顿的饭。</p><p>在学校想吃个水果吧，要骑着小电驴去北亭采购，纠结一番，选择的最佳标准就是: 不用剥皮，方便吃就行。</p><p>在家里，你会被建议吃一些复杂的水果，要剥皮？不存在的，只需要你点一点头，削好皮的水果就递在你眼前了，果核往桌上一放就会自动消失。</p><p>在学校泡脚这种复杂的活真是少见，烧水，备桶，加盐，兑冷水，时刻准备着加热…反正一年泡不到两次吧…</p><p>在家里，你会被提议泡个脚，只要你点一点头，在看电视的空挡，热腾腾的泡脚水不知什么时候已在脚边，实在是惭愧，自己才是那个“巨婴”吧。</p><p>妈妈睡眠不好，胃口极好。</p><p>我担心她，拖她去看睡眠障碍医生，又担心她日益见长的肚腩对膝盖沉重的负担，和她一起践行健康饮食，减少碳水，督促她每天做一分钟平板支撑。</p><p>妈妈说最近睡眠不错，没什么运动量也一直在平稳掉秤。</p><p>老爸牙疼，牙结石臭气熏天，我在试图说服他去洗个牙，但他有他的一套“处事准则”，不可轻易动摇。我用自己的洗牙体验，引经据典，旁敲侧击的告诉他洗牙的好处。</p><p>他在动摇，也许明年回来就要成功击溃他内心的城墙。</p><p>最喜欢的是不落雨的时候，一家人的默契是一定要出去散个步。</p><p>俺们家是犬系动物，非得出去溜溜，不然闷得慌。</p><p>踏着湖边的大好景色，一直走下去，永远不会腻。</p><p>湖景不像大海，大海是浅蓝浅蓝的，一眼望不到边。也不像深山里的九寨沟，是清澈见底的浅滩碧绿。千岛湖的水是望不穿的翡翠般的深绿，矮山远近重叠，小岛错落有致，夕阳打在上面是少女粉色的，粉的发紫。</p><p>小时候我总好奇，跑到湖边捧起一手，“翡翠”就不见了，只看得到清晰的掌纹。</p><p>按理来说，此情此景，从小在这长大的我早该厌倦了罢，就像厌倦了朝九晚五和一层不变的生活。</p><p>可偏偏是每望一次都有一次的欣喜和平静。这叫人如何舍得！</p><p>不管自己多大，不管走的多远，在父母眼里始终是个生活不能自理，不会照顾自己的傻瓜。</p><p>感谢爸爸妈妈的温柔以待，以身作则，让我更加懂得如何照顾一个人，如果表达自然流露，奔涌而出，温润如水的爱意。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启程回学校。漫天雪飘，高速隧道。浪漫又凄凄。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/dCwhicdySicfPT9CJAIic13O8JPj75F1TKpzDeOZVXs8AyA6vNZCS1BpFhMeFT</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://yunbujian.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yunbujian.github.io/1999/02/19/hello-world/"/>
    <id>https://yunbujian.github.io/1999/02/19/hello-world/</id>
    <published>1999-02-18T16:00:00.000Z</published>
    <updated>2022-02-21T12:58:56.757Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
